<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shirly</title>
  
  <subtitle>subtitle</subtitle>
  <link href="/h-blog/atom.xml" rel="self"/>
  
  <link href="https://zdddrszj.github.io/h-blog/"/>
  <updated>2018-10-07T01:46:42.307Z</updated>
  <id>https://zdddrszj.github.io/h-blog/</id>
  
  <author>
    <name>Shirly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 简单实现（一）</title>
    <link href="https://zdddrszj.github.io/h-blog/2018/10/07/reactAchieved1/"/>
    <id>https://zdddrszj.github.io/h-blog/2018/10/07/reactAchieved1/</id>
    <published>2018-10-07T01:46:10.000Z</published>
    <updated>2018-10-07T01:46:42.307Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#一-前言">一、前言</a></li><li><a href="#二-createelement-实现">二、createElement 实现</a></li><li><a href="#三-render-实现">三、render 实现</a><ul><li><a href="#1-字符串类型">1、字符串类型</a></li><li><a href="#2-标签类型">2、标签类型</a></li><li><a href="#3-函数类型">3、函数类型</a></li></ul></li><li><a href="#四-setstate-实现">四、setState 实现</a></li></ul><!-- tocstop --><p><code>React</code> 是一款用于构建用户界面的 <code>JavaScript</code> 库。它以声明式编写 <code>UI</code>，创建拥有各自状态的组件，再由组件构成更加复杂的界面。</p><h2><span id="一-前言">一、前言</span></h2><p>在 <code>React</code> 中我们使用 <code>JSX</code> 语法来替代常规的  <code>JavaScript</code>，并通过 <code>Babel</code> 编译，比如例子1：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX语法</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"title"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Babel编译后</span></span><br><span class="line"><span class="keyword">var</span> str = React.createElement(</span><br><span class="line">  <span class="string">"h1"</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">"title"</span> &#125;,</span><br><span class="line">  <span class="string">"hello"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>然后我们控制台输出 <code>str</code>，得到结果如下：<br><img src="https://user-gold-cdn.xitu.io/2018/7/27/164dc02769830bd2?w=24&amp;f=png&amp;s=30515" alt=""><br>例子2：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX语法</span></span><br><span class="line"><span class="keyword">let</span> App = <span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello&#123;props.value&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Babel编译后</span></span><br><span class="line"><span class="keyword">var</span> App = <span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(</span><br><span class="line">    <span class="string">"h1"</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">"hello"</span>,</span><br><span class="line">    props.value</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出 <code>App</code>，得到结果如下：<br><img src="https://user-gold-cdn.xitu.io/2018/7/27/164dc63f58c8a996?w=378&amp;h=50&amp;f=png&amp;s=31369" alt=""></p><p>这个对象就是虚拟 <code>DOM</code> 对象，最后通过 <code>ReactDOM.render</code> 方法将虚拟 <code>DOM</code> 解析渲染到页面上。下面我们就分别来实现 <code>createElement</code> 和 <code>render</code> 方法。</p><h2><span id="二-createelement-实现">二、createElement 实现</span></h2><p>此方法就是实现一个数据结构，把 <code>JSX</code> 编译后的结构以嵌套形式保存在数据结构对象中，实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create and return a new ReactElement of the given type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span> (<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children: children.length &lt;= <span class="number">1</span> ? children[<span class="number">0</span>] : children</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="三-render-实现">三、render 实现</span></h2><p><code>render</code> 函数就是解析虚拟 <code>DOM</code>，然后通过 <code>appendChild</code> 渲染到页面上，实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将真实dom渲染到页面</span></span><br><span class="line"><span class="comment"> * @param &#123;*虚拟dom&#125; vnode </span></span><br><span class="line"><span class="comment"> * @param &#123;*页面容器&#125; container </span></span><br><span class="line"><span class="comment"> * @param &#123;*渲染后的回调&#125; callback </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">vnode, container, callback</span>) </span>&#123;</span><br><span class="line">  container.appendChild(_render(vnode))</span><br><span class="line">  callback &amp;&amp; callback()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将虚拟dom转成真实节点</span></span><br><span class="line"><span class="comment"> * @param &#123;*虚拟dom&#125; vnode </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_render</span> (<span class="params">vnode</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>但是虚拟 <code>DOM</code> 的有三种类型，不同类型有不同的渲染方式，下面我们分别来分析一下。</p><h3><span id="1-字符串类型">1、字符串类型</span></h3><p>字符串类型即是文本，比如上面的 <code>hello</code>，直接创建文本节点返回即可，实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_render</span> (<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是普通字符</span></span><br><span class="line">  <span class="keyword">if</span> (util.isString(vnode) || util.isNumber(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="2-标签类型">2、标签类型</span></h3><p>常见标签如 <code>div/h1/span</code> 等，创建元素标签后需要遍历设置属性，实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_render</span> (<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; type, props &#125; = vnode</span><br><span class="line">  <span class="keyword">let</span> &#123; children, ...attrs &#125; = props</span><br><span class="line">  <span class="comment">// 如果是标签元素，如 div span</span></span><br><span class="line">  <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(type)</span><br><span class="line">  <span class="keyword">if</span> (children) &#123;</span><br><span class="line">    <span class="keyword">if</span> (util.isArray(children)) &#123;</span><br><span class="line">      children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">        render(child, dom)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dom.appendChild(<span class="built_in">document</span>.createTextNode(children))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置属性</span></span><br><span class="line">  setAttributes(attrs, dom)</span><br><span class="line">  <span class="keyword">return</span> dom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="3-函数类型">3、函数类型</span></h3><p>函数类型也分二种情况，一种是无状态普通函数即函数组件，另一种则是继承了 <code>React.Component</code> 类的有状态函数，即类组件。开始之前需要定义一个  <code>Component</code> 父类以便继承，实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create React.Component class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Component: componentWillMount'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Component: componentDidMount'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  setState () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Component: setState'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不管哪种组件，为了保证行为统一性，我们可以分别经过组件创建，组件渲染，然后返回真实 <code>DOM</code> 节点，最后渲染到页面上的步骤。实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_render</span> (<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; type, props &#125; = vnode</span><br><span class="line">  <span class="keyword">let</span> &#123; children, ...attrs &#125; = props</span><br><span class="line">  <span class="comment">// 如果是函数，说明是组件（包括函数组件和类组件）</span></span><br><span class="line">  <span class="keyword">if</span> (util.isFunction(type)) &#123;</span><br><span class="line">    <span class="comment">// 创建组件</span></span><br><span class="line">    <span class="keyword">let</span> comp = createComponent(type, props)</span><br><span class="line">    comp.props = props</span><br><span class="line">    <span class="comment">// 渲染组件</span></span><br><span class="line">    <span class="keyword">let</span> dom = renderComponent(comp)</span><br><span class="line">    comp.dom = dom</span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    setAttributes(attrs, dom)</span><br><span class="line">    <span class="keyword">return</span> dom</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params">comp, props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是类组件，需要new一个实例，可以调用render方法</span></span><br><span class="line">  <span class="keyword">if</span> (comp.prototype.render) &#123;</span><br><span class="line">    comp = <span class="keyword">new</span> comp(props)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    comp.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> comp(props)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> comp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染组件：执行组件的render方法，然后通过_render将虚拟dom转成真实dom，最后返回真实节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderComponent</span> (<span class="params">comp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dom</span><br><span class="line">  <span class="comment">// 如果未渲染过组件</span></span><br><span class="line">  <span class="keyword">if</span> (!comp.dom) &#123;</span><br><span class="line">    <span class="keyword">if</span> (comp.componentWillMount) &#123;</span><br><span class="line">      comp.componentWillMount()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dom = _render(comp.render())</span><br><span class="line">  <span class="keyword">if</span> (comp.componentDidMount) &#123;</span><br><span class="line">    comp.componentDidMount()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里解析和渲染功能大体完成，下面介绍一下如何修改组件状态。</p><h2><span id="四-setstate-实现">四、setState 实现</span></h2><p>在上面我们通过 <code>setAttribute</code> 已经将事件绑定到元素上，事件中很有可能会修改组件状态，比如<code>this.setState({a: this.state.a + 1})</code> 语句，以此更新视图。不过通过上面虚拟 <code>DOM</code> 解析成真实 <code>DOM</code> 的学习，在这里先忽略 <code>DOM Diff</code> 功能，重新渲染还是很好实现的，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  setState (newState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Component: setState'</span>)</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>.state, newState)</span><br><span class="line">    <span class="keyword">let</span> old = <span class="keyword">this</span>.dom</span><br><span class="line">    <span class="comment">// renderComponent：整体重新渲染，然后返回真实节点</span></span><br><span class="line">    <span class="keyword">let</span> newDom = renderComponent(<span class="keyword">this</span>)</span><br><span class="line">    old.parentNode.replaceChild(newDom, old)</span><br><span class="line">    <span class="keyword">this</span>.dom = newDom</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/zdddrszj/react-source-study" target="_blank" rel="noopener">源码</a></p><p>好了，今天的学习就先到这里吧😋😋😋～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-前言&quot;&gt;一、前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二-createelement-实现&quot;&gt;二、createElement 实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三-render-实现&quot;
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react" scheme="https://zdddrszj.github.io/h-blog/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>bind 简单介绍</title>
    <link href="https://zdddrszj.github.io/h-blog/2018/09/13/bind-md/"/>
    <id>https://zdddrszj.github.io/h-blog/2018/09/13/bind-md/</id>
    <published>2018-09-13T11:02:49.000Z</published>
    <updated>2018-10-07T00:52:49.912Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#一-bind-方法的作用">一、bind 方法的作用</a><ul><li><a href="#1-修改-this-指向">1、修改 this 指向</a></li><li><a href="#2-可以实现偏函数的效果">2、可以实现偏函数的效果</a></li><li><a href="#3-bind-多次时-this-总是指向第一次-bind-的对象">3、bind 多次时 this 总是指向第一次 bind 的对象</a></li><li><a href="#4-绑定构造函数">4、绑定构造函数</a></li></ul></li><li><a href="#二-bind-方法的实现">二、bind 方法的实现</a><ul><li><a href="#1-修改-this-指向-1">1、修改 this 指向</a></li><li><a href="#2-实现类似-curry-化的效果">2、实现类似 curry 化的效果</a></li><li><a href="#3-绑定构造函数">3、绑定构造函数</a></li><li><a href="#4-mozilla-官方实现">4、mozilla 官方实现</a></li></ul></li></ul><!-- tocstop --><h3><span id="一-bind-方法的作用">一、bind 方法的作用</span></h3><h4><span id="1-修改-this-指向">1、修改 this 指向</span></h4><p>请看如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="built_in">document</span>.querySelector</span><br><span class="line"><span class="keyword">const</span> div = $(<span class="string">'div'</span>)</span><br><span class="line"><span class="comment">// Uncaught TypeError: Illegal invocation</span></span><br></pre></td></tr></table></figure></p><p>这段代码报类型错误，因为window对象下并没有querySelector方法。可以用bind解决，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="built_in">document</span>.querySelector.bind(<span class="built_in">document</span>)</span><br><span class="line"><span class="keyword">const</span> div = $(<span class="string">'div'</span>)</span><br><span class="line"><span class="comment">// 返回结果 &lt;div&gt;......&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></p><p>其他实现方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="built_in">document</span>.querySelector</span><br><span class="line"><span class="keyword">const</span> div = $.call(<span class="built_in">document</span>,<span class="string">'div'</span>)</span><br><span class="line"><span class="comment">// 返回结果 &lt;div&gt;......&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></p><p>call 和 apply 函数的缺陷是不能返回一个新方法。</p><h4><span id="2-可以实现偏函数的效果">2、可以实现偏函数的效果</span></h4><p>bind方法可以返回一个新函数，而且可以在绑定的时候传入其他参数，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">...args</span>) =&gt;</span> args.reduce(<span class="function">(<span class="params">prev,next</span>) =&gt;</span> prev+next, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> sum2 = sum.bind(<span class="literal">null</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum2(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p><h4><span id="3-bind-多次时-this-总是指向第一次-bind-的对象">3、bind 多次时 this 总是指向第一次 bind 的对象</span></h4><p>运行如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  name:<span class="string">'zhangsan'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2= &#123;</span><br><span class="line">  name: <span class="string">'lisi'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> name = getName.bind(p1).bind(p2)</span><br><span class="line">name() <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure></p><h4><span id="4-绑定构造函数">4、绑定构造函数</span></h4><p>运行如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName</span><br><span class="line">  <span class="keyword">this</span>.lastName = lastName</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.firstName + <span class="keyword">this</span>.lastName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">'zhang'</span>, <span class="string">'san'</span>) <span class="comment">// zhangsan</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> P = Person.bind(<span class="literal">null</span>, <span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> P(<span class="string">'si'</span>) <span class="comment">// lisi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> Person) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p3 <span class="keyword">instanceof</span> Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>从如上结果可以看出，<code>bind</code> 实现中要根据当前调用函数 <code>this</code> 是否是被绑定函数的实例，如果是，修改 <code>this</code> 为当前调用者的 <code>this</code></p><h3><span id="二-bind-方法的实现">二、bind 方法的实现</span></h3><blockquote><p>语法：<code>fun.bind(thisArg[, arg1[, arg2[, ...]]])</code><br>  参数：<code>thisArg</code> -&gt; 调用绑定函数时作为this参数传递给目标函数的值。<br>        <code>arg1, arg2, ... -&gt;</code> 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。<br> 返回值：返回由指定的 <code>this</code> 值和初始化参数改造的原函数拷贝</p></blockquote><h4><span id="1-修改-this-指向">1、修改 this 指向</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.apply(oThis, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="2-实现类似-curry-化的效果">2、实现类似 curry 化的效果</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> self.apply(oThis, aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="3-绑定构造函数">3、绑定构造函数</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> currentThis = <span class="keyword">this</span> <span class="keyword">instanceof</span> fun ? <span class="keyword">this</span> : oThis</span><br><span class="line">    <span class="keyword">return</span> self.apply(currentThis, aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">  fun.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">  fBound.prototype = <span class="keyword">new</span> fun()</span><br><span class="line">  <span class="keyword">return</span> fBound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="4-mozilla-官方实现">4、mozilla 官方实现</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind - what is trying to be bound is not callable'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs   = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        fToBind = <span class="keyword">this</span>,</span><br><span class="line">        fNOP    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fBound  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// this instanceof fNOP === true时,说明返回的fBound被当做new的构造函数调用</span></span><br><span class="line">          <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP</span><br><span class="line">                 ? <span class="keyword">this</span></span><br><span class="line">                 : oThis,</span><br><span class="line">                 <span class="comment">// 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的</span></span><br><span class="line">                 aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护原型关系</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">      <span class="comment">// Function.prototype doesn't have a prototype property</span></span><br><span class="line">      fNOP.prototype = <span class="keyword">this</span>.prototype; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下行的代码使fBound.prototype是fNOP的实例,因此</span></span><br><span class="line">    <span class="comment">// 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例</span></span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-bind-方法的作用&quot;&gt;一、bind 方法的作用&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-修改-this-指向&quot;&gt;1、修改 this 指向&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-可以实现偏函数
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="bind" scheme="https://zdddrszj.github.io/h-blog/tags/bind/"/>
    
  </entry>
  
  <entry>
    <title>Promise 简单实现</title>
    <link href="https://zdddrszj.github.io/h-blog/2018/07/19/promiseAchieved/"/>
    <id>https://zdddrszj.github.io/h-blog/2018/07/19/promiseAchieved/</id>
    <published>2018-07-19T03:42:24.000Z</published>
    <updated>2018-10-07T00:52:49.913Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#一-promise-构造函数实现">一、Promise 构造函数实现</a></li><li><a href="#二-promisethen-实现">二、Promise.then 实现</a><ul><li><a href="#1-then-订阅功能">1、then 订阅功能</a></li><li><a href="#2-then-返回-promise">2、then 返回 promise</a></li><li><a href="#2-then-调用多次">2、then 调用多次</a></li><li><a href="#3-状态不可逆转">3、状态不可逆转</a></li><li><a href="#4-promisethen-异步执行">4、Promise.then 异步执行</a></li><li><a href="#5-promisethen-穿透">5、Promise.then 穿透</a></li></ul></li><li><a href="#三-其它方法实现">三、其它方法实现</a><ul><li><a href="#1-promiseresolve">1、Promise.resolve</a></li><li><a href="#2-promisereject">2、Promise.reject</a></li><li><a href="#3-promiseall">3、Promise.all</a></li><li><a href="#4-promiserace">4、Promise.race</a></li><li><a href="#5-promisepromisify">5、Promise.promisify</a></li></ul></li><li><a href="#四-promise-校验">四、Promise 校验</a></li></ul><!-- tocstop --><p>今天的任务是根据<code>Promise A+</code> 规范简单实现一个 <code>Promise</code> 库。开始之前，我们可以先通读一下这个规范，<a href="https://promisesaplus.com/" target="_blank" rel="noopener">戳这里</a>。</p><p>静心读一下这个规范真的很重要，很重要，很重要。虽然是英文版，但是读起来也许会比汉语更能让人理解。</p><p><code>A promise represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its then method, which registers callbacks to receive either a promise’s eventual value or the reason why the promise cannot be fulfilled.</code></p><p>提到 <code>Promise</code> 自然想到异步，异步想到回调，回调就是回头在调。回头在调的前提是提前存储回调内容，等到时间后从存储的地方取到对应的内容再执行即可。</p><h2><span id="一-promise-构造函数实现">一、Promise 构造函数实现</span></h2><p><code>2.1 A promise must be in one of three states: pending, fulfilled, or rejected.</code></p><p><code>2.1.1 A pending promise may transition to either the fulfilled or rejected state.</code></p><p><code>2.1.2 A fulfilled promise must have a value, which must not change.</code></p><p><code>2.1.3 A rejected promise must have a reason, which must not change.</code></p><p>我们平时但凡做什么事情，大概都有三种基本状态，正在进行、成功、失败。一个 <code>Promise</code> 代表一个异步操作，也有这三种状态，且状态只能从正在进行到成功或者失败，不可逆转。不管事情最终什么状态，既然结果出来了，那就通知之前缓存回调的数组（因为可以 <code>then</code> 多次，故为数组）并把结果给它吧。</p><p><code>Promise</code> 基本使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'success'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(data)&#125;)</span><br></pre></td></tr></table></figure></p><p>首先 <code>Promise</code> 是一个类，通过 <code>new</code> 创建一个实例，参数是一个函数，函数参数默认命名为 <code>resolve</code> 和 <code>reject</code>，我们称该函数为一个执行器 <code>executor</code>，默认执行。构造函中还需要一个状态变量 <code>status</code>，保存当前执行状态；以及执行成功 <code>value</code> 或失败 <code>reason</code> 的结果变量；最后还需要上面提及的缓存回调的数组。实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> () </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (executor) &#123;</span><br><span class="line">        <span class="comment">// 默认等待态</span></span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">        <span class="comment">// 成功结果</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">        <span class="comment">// 失败原因</span></span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line">        <span class="comment">// 存储成功回调数组</span></span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks = []</span><br><span class="line">        <span class="comment">// 存储失败回调数组</span></span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = []</span><br><span class="line">        <span class="comment">// 执行器</span></span><br><span class="line">        executor(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行器函数参数是 <code>resolve</code> 和 <code>reject</code>， 同样也是函数，功能是有结果后触发缓存回调数组，也可以理解为发布。实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> () </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (executor) &#123;</span><br><span class="line">        <span class="comment">// 变量声明</span></span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks = []</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = []</span><br><span class="line">        <span class="comment">// 结果成功，通知函数定义</span></span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = <span class="string">'resolved'</span></span><br><span class="line">                <span class="keyword">this</span>.value = value</span><br><span class="line">                <span class="keyword">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果失败，通知函数定义</span></span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">                <span class="keyword">this</span>.reason = reason</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>既然有结果后要触发缓存回调数组，那么接下来我们看一下这个回调数组如何缓存。</p><h2><span id="二-promisethen-实现">二、Promise.then 实现</span></h2><p><code>2.2 A promise must provide a then method to access its current or eventual value or reason.</code></p><h3><span id="1-then-订阅功能">1、then 订阅功能</span></h3><p>我们都知道，<code>promise</code> 实例只有通过调用 <code>then</code> 函数才能拿到结果，<code>then</code> 函数参数分别为成功回调和失败回调，回调参数为成功值和失败值。固 <code>then</code> 函数的主要功能即是缓存回调函数，也可以理解为订阅。实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> () </span>&#123;</span><br><span class="line">    <span class="comment">// constructor省略...</span></span><br><span class="line">    then (onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 如果exector内容为同步代码，resolve函数执行后，状态已变为resolved，则直接执行回调</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">            onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 如果exector内容为同步代码，reject函数执行后，状态已变为rejected，直接执行回调</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">           onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果exector内容为异步代码，状态为pending时，则缓存回调函数，我们也可以理解为订阅</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">               onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="2-then-返回-promise">2、then 返回 promise</span></h3><p><code>2.2.6 Then may be called multiple times on the same promise.</code></p><p><code>2.2.7 Then must return a promise. promise2 = promise1.then(onFulfilled, onRejected)</code></p><p>实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> () </span>&#123;</span><br><span class="line">    <span class="comment">// constructor省略...</span></span><br><span class="line">    then (onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="keyword">let</span> promise2</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">            promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">            promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">            promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="2-then-调用多次">2、then 调用多次</span></h3><p><code>2.2.7.1 onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).</code></p><p><code>then</code> 可以调用多次，且每次 <code>then</code> 参数 <code>onFulFilled</code> 函数的参数值为上一次 <code>promise</code> 函数的执行结果，即为 <code>onFulfilled(this.value)</code> 的执行结果，我们设为 <code>x</code>。根据 <code>x</code> 的不同情况做不同处理，详情见 <code>Promise A+</code> 规范 <code>2.3 Promise Resolution Procedure</code>。</p><p>实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> () </span>&#123;</span><br><span class="line">    <span class="comment">// constructor省略...</span></span><br><span class="line">    then (onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="keyword">let</span> promise2</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">            promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">                <span class="comment">// Promise Resolution Procedure</span></span><br><span class="line">                resolvePromise(promise2, x, resolve. reject)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">            promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">                <span class="comment">// Promise Resolution Procedure</span></span><br><span class="line">                resolvePromise(promise2, x, resolve. reject)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">            promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">                    <span class="comment">// Promise Resolution Procedure</span></span><br><span class="line">                    resolvePromise(promise2, x, resolve. reject)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理函数：处理promise2和x的关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span> (<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.3.1 If promise and x refer to the same object, reject promise with a TypeError as the reason.</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  2.3.3 if x is an object or function</span></span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span> )&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.3.3.1 Let then be x.then.</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then</span><br><span class="line">            <span class="comment">// 2.3.3.3 If then is a function，call it with x as this.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="comment">// 2.3.3.3.1 If/when resolvePromise is called with a value y, run [[Resolve]](promise, y)</span></span><br><span class="line">                then.call(x, y =&gt; &#123;</span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">                &#125;, r =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 2.3.3.3.2 If/when rejectPromise is called with a reason r, reject promise with r.</span></span><br><span class="line">                    reject(r)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 2.3.3.4 If calling then throws an exception e</span></span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.3.4 If x is not an object or function, fulfill promise with x.</span></span><br><span class="line">        resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="3-状态不可逆转">3、状态不可逆转</span></h3><p>实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理函数：处理promise2和x的关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span> (<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.3.1 If promise and x refer to the same object, reject promise with a TypeError as the reason.</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> called</span><br><span class="line">    <span class="comment">//  2.3.3 if x is an object or function</span></span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span> )&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.3.3.1 Let then be x.then.</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then</span><br><span class="line">            <span class="comment">// 2.3.3.3 If then is a function，call it with x as this.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="comment">// 2.3.3.3.1 If/when resolvePromise is called with a value y, run [[Resolve]](promise, y)</span></span><br><span class="line">                then.call(x, y =&gt; &#123;</span><br><span class="line">                    <span class="comment">// `2.3.3.3.3 If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.`</span></span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span></span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">                &#125;, r =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span></span><br><span class="line">                    <span class="comment">// 2.3.3.3.2 If/when rejectPromise is called with a reason r, reject promise with r.</span></span><br><span class="line">                    reject(r)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// `2.3.3.3.4 If calling then throws an exception e，2.3.3.3.4.1 If resolvePromise or rejectPromise have been called, ignore it.`</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 2.3.3.4 If calling then throws an exception e</span></span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.3.4 If x is not an object or function, fulfill promise with x.</span></span><br><span class="line">        resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="4-promisethen-异步执行">4、Promise.then 异步执行</span></h3><p>实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> () </span>&#123;</span><br><span class="line">    then (onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="keyword">let</span> promise2</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">            promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">            promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;. <span class="number">0</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">            promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">                            promiseResolve(promise2, x, resolve, reject)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">                            promiseResolve(promise2, x, resolve, reject)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="5-promisethen-穿透">5、Promise.then 穿透</span></h3><p><code>promise.then().then()</code> 多次，都可以获取到最终结果，固当 <code>then</code> 参数 <code>onFulfilled</code> 为空时，需要自动 <code>return value</code>；当 <code>onRejected</code>  为空时，需要 <code>return throw err</code>。实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> () </span>&#123;</span><br><span class="line">    then (onFulfilled, onRejected) &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line">        <span class="comment">// promise2省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="三-其它方法实现">三、其它方法实现</span></h2><h3><span id="1-promiseresolve">1、Promise.resolve</span></h3><p>实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(val)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="2-promisereject">2、Promise.reject</span></h3><p>实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(val)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="3-promiseall">3、Promise.all</span></h3><p>实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dataArr = []</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                dataArr[i] = data</span><br><span class="line">                count++</span><br><span class="line">                <span class="keyword">if</span> (count === promises.lenth) &#123;</span><br><span class="line">                    resolve(dataArr)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="4-promiserace">4、Promise.race</span></h3><p>实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promise[i].then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="5-promisepromisify">5、Promise.promisify</span></h3><p>实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.promisify = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            fn(...args, (err, data) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) reject(err)</span><br><span class="line">                resolve(data)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="四-promise-校验">四、Promise 校验</span></h2><p>要想验证自己实现的 <code>Promise</code> 是否符合 <code>Promise A+</code> 规范，可以全局安装 <code>promises-aplus-tests</code> 工具包。</p><p><code>Adapters</code>：</p><p><code>In order to test your promise library, you must expose a very minimal adapter interface. These are written as Node.js modules with a few well-known exports:</code></p><ul><li><code>resolved(value): creates a promise that is resolved with value.</code></li><li><code>rejected(reason): creates a promise that is already rejected with reason.</code></li><li><code>deferred(): creates an object consisting of { promise, resolve, reject }</code></li></ul><blockquote><p><code>The resolved and rejected exports are actually optional, and will be automatically created by the test runner using deferred</code></p></blockquote><p><code>resolved</code> 和 <code>rejected</code> 是可选的，下面我们实现一下 <code>deferred</code>，实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dfd = &#123;&#125;</span><br><span class="line">    dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        dfd.resolve = resolve</span><br><span class="line">        dfd.reject = reject</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> dfd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里一切准备就绪，校验步骤如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install promises-aplus-tests -g</span><br><span class="line">promises-aplus-tests ./Promise.js</span><br></pre></td></tr></table></figure></p><p><br></p><p><a href="https://github.com/zdddrszj/promise" target="_blank" rel="noopener">源码</a></p><p>好了，到这里全部代码都已呈现，赶快自己亲手试一下吧！😋😋😋</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-promise-构造函数实现&quot;&gt;一、Promise 构造函数实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二-promisethen-实现&quot;&gt;二、Promise.then 实现&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="promise" scheme="https://zdddrszj.github.io/h-blog/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>ReadableStream 简单实现</title>
    <link href="https://zdddrszj.github.io/h-blog/2018/07/12/readableStream/"/>
    <id>https://zdddrszj.github.io/h-blog/2018/07/12/readableStream/</id>
    <published>2018-07-12T07:42:44.000Z</published>
    <updated>2018-10-07T00:52:49.913Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#一-创建可读流">一、创建可读流</a></li><li><a href="#二-读取长度小于水位线">二、读取长度小于水位线</a></li><li><a href="#三-读取长度等于水位线">三、读取长度等于水位线</a></li><li><a href="#四-读取长度大于水位线">四、读取长度大于水位线</a></li></ul><!-- tocstop --><p>今天的文章需要提前了解一下 <code>node</code> 中 <code>fs</code> 模块的相关 <code>api</code>，不太熟悉的同学可以<a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener">点这里</a>。</p><blockquote><p>众所周知，<code>node</code> 中的 <code>fs</code> 模块功能大都与文件相关，比如可以通过 <code>fs.createReadStream</code> 创建文件可读流，通过<code>fs.createWriteStream</code> 创建文件可写流，还可以通过监听 <code>open</code>、<code>data</code>、<code>end</code>、<code>error</code>、<code>readable</code> 事件对数据进行操作。由于时间有限，今天我们先来实现一下 <code>readable</code> 事件功能。</p></blockquote><p>开始之前，先简单介绍一下可读流函数 <code>fs.createReadStream(path[, options])</code> 中各参数所代表的含义，如下所示：</p><ul><li><code>path &lt;string&gt; | &lt;Buffer&gt; | &lt;URL&gt;</code> 创建可读流的路径</li><li><code>options &lt;string&gt; | &lt;Object&gt;</code> 可选参数<ul><li><code>flags &lt;string&gt;</code> 文件读写标识，默认为 r</li><li><code>encoding &lt;string&gt;</code> 读取编码格式，默认为 null</li><li><code>fd &lt;integer&gt;</code> 文件描述符，默认为 null</li><li><code>mode &lt;integer&gt;</code> 文件操作权限，默认为 0o666</li><li><code>autoClose &lt;boolean&gt;</code> 文件是否自动关闭，默认为 true</li><li><code>start &lt;integer&gt;</code> 文件读取开始位置，默认为 0</li><li><code>end &lt;integer&gt;</code> 文件读取结束位置，默认为 Infinity</li><li><code>highWaterMark &lt;integer&gt;</code> 水位线，每次读取长度，默认为 64字节（64 * 1024）</li></ul></li></ul><h2><span id="一-创建可读流">一、创建可读流</span></h2><p>首先我们需要实现一个可读流的类，不防定义为 <code>ReadableStream</code>，该类可以通过 <code>on</code> 函数进行事件监听，所以需要继承 <code>node</code> 中 <code>EventEmitter</code> 类；<br>当监听 <code>readable</code> 函数时可读取到文件内容，由此得知在构造函数中除了需要定义上面的变量，还需要调用打开文件和第一次读取文件的功能。代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadableStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.path = path</span><br><span class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span></span><br><span class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span> * <span class="number">1024</span></span><br><span class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.end = options.end || <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="number">0o666</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否正在读取文件</span></span><br><span class="line">    <span class="keyword">this</span>.reading = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 当len=0时，触发readable事件</span></span><br><span class="line">    <span class="keyword">this</span>.emitReadable = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 缓存中字节的长度</span></span><br><span class="line">    <span class="keyword">this</span>.len = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 缓存每次读取的内容，格式为[&lt;Buffer /&gt;, &lt;Buffer /&gt;, ...]</span></span><br><span class="line">    <span class="keyword">this</span>.arr = []</span><br><span class="line">    <span class="comment">// 文件读取的位置</span></span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start</span><br><span class="line">    <span class="comment">// 是否文件全部读取完</span></span><br><span class="line">    <span class="keyword">this</span>.finished = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">this</span>.open()</span><br><span class="line">    <span class="comment">// 判断用户是否监听了readable事件</span></span><br><span class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, (type) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (type === <span class="string">'readable'</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一次文件读取</span></span><br><span class="line">        <span class="keyword">this</span>.read()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = ReadableStream</span><br></pre></td></tr></table></figure></p><p>构造函数中其它变量可以先忽略，到实现阶段时我相信大家自然清晰其用处。<br>下面利用 <code>fs.open</code> 和 <code>fs.destory</code> 实现 <code>open</code> 和 <code>destory</code> 功能。实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开可读流</span></span><br><span class="line">open() &#123;</span><br><span class="line">  fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'error'</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.autoClose) &#123;</span><br><span class="line">        <span class="keyword">this</span>.destory()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fd = fd</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'open'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭可读流，参数为文件描述符</span></span><br><span class="line">destory() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd === <span class="string">'number'</span>) &#123;</span><br><span class="line">    fs.close(<span class="keyword">this</span>.fd, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来看下初次读取时的 <code>read</code> 函数。</p><blockquote><p>实现思路：在构造函数中，当触发第一次读取文件时，读取大小为 <code>highWaterMark</code> 个，不防我们将比较读取长度和缓存长度的方法设定为 <code>read</code>。然后再 <code>read</code> 函数中判断，如果缓存区长度为 <code>0</code> 时，表明可以触发 <code>readable</code> 事件；如果缓存区长度小于水位线时，则进行文件读取，此时我们将真正读取文件的函数命名为 <code>_read</code>；最后，根据编码格式进行返回数据。</p></blockquote><p>实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadableStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处如上，省略...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 可读流实例调用的方法</span></span><br><span class="line">  read () &#123;</span><br><span class="line">    <span class="keyword">let</span> buffer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存区长度为0时，表明可以触发readable事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.len === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emitReadable = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存区长度小于水位线时，则进行文件读取</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.len &lt; <span class="keyword">this</span>.highWaterMark) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.reading) &#123;</span><br><span class="line">        <span class="keyword">this</span>.reading = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">this</span>._read()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据编码方式处理数据</span></span><br><span class="line">    <span class="keyword">if</span> (buffer) &#123;</span><br><span class="line">      buffer = <span class="keyword">this</span>.encoding ? buffer.toString(<span class="keyword">this</span>.encoding) : buffer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 真实读取文件的方法</span></span><br><span class="line">  _read () &#123;</span><br><span class="line">    <span class="comment">// 因为打开文件为异步操作，当读取时文件未打开，可以通过注册一次open事件，打开后执行回调即可拿到this.fd</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.once(<span class="string">'open'</span>, () =&gt; <span class="keyword">this</span>._read())</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> howMuchToRead = <span class="keyword">this</span>.end ? <span class="built_in">Math</span>.min(<span class="keyword">this</span>.highWaterMark, <span class="keyword">this</span>.end - <span class="keyword">this</span>.pos + <span class="number">1</span>) : <span class="keyword">this</span>.highWaterMark</span><br><span class="line">    <span class="keyword">let</span> buffer = Buffer.alloc(howMuchToRead)</span><br><span class="line">    fs.read(<span class="keyword">this</span>.fd, buffer, <span class="number">0</span>, <span class="keyword">this</span>.howMuchToRead, <span class="keyword">this</span>.pos, (err, bytesRead) =&gt; &#123;</span><br><span class="line">      <span class="comment">// bytesRead 为文件读取到的长度</span></span><br><span class="line">      <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将读取的内容缓存到arr数组中</span></span><br><span class="line">        <span class="keyword">this</span>.arr.push(buffer)</span><br><span class="line">        <span class="comment">// 相关变量更新</span></span><br><span class="line">        <span class="keyword">this</span>.len += bytesRead</span><br><span class="line">        <span class="keyword">this</span>.pos += bytesRead</span><br><span class="line">        <span class="keyword">this</span>.reading = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 缓存后触发实例上用户调用的read函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.emitReadable) &#123;</span><br><span class="line">          <span class="keyword">this</span>.emitReadable = <span class="literal">false</span></span><br><span class="line">          <span class="keyword">this</span>.emit(<span class="string">'readable'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处如上，省略...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当前 <code>1.txt</code> 文件中的内容为 <code>1234567890</code>。调用方式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">let</span> ReadableStream = <span class="built_in">require</span>(<span class="string">'./ReadableStream'</span>)</span><br><span class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadableStream(<span class="string">'./1.txt'</span>, &#123;</span><br><span class="line">  autoClose: <span class="literal">true</span>,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  flags: <span class="string">'r'</span>,</span><br><span class="line">  encoding: <span class="string">'utf8'</span>,</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>接下来从缓存区中读取数据。</p><h2><span id="二-读取长度小于水位线">二、读取长度小于水位线</span></h2><p>当读取长度小于水位线时，使用原生方式调用，可以得到如下结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./1.txt'</span>, &#123;</span><br><span class="line">  autoClose: <span class="literal">true</span>,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  flags: <span class="string">'r'</span>,</span><br><span class="line">  encoding: <span class="string">'utf8'</span>,</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> r = rs.read(<span class="number">2</span>)</span><br><span class="line">  <span class="comment">// 输出结果为 12</span></span><br><span class="line">  <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>由此可知，如果缓冲区内容够读，则返回结果结束读取。实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadableStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处如上，省略...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可读流实例调用的方法</span></span><br><span class="line">  read (n) &#123;</span><br><span class="line">    <span class="comment">// 如果参数为空且不是在构造函数中调用此函数，n 默认按highWaterMark处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'undefined'</span> &amp;&amp; <span class="keyword">this</span>.pos &gt; <span class="keyword">this</span>.start) &#123;</span><br><span class="line">      n = <span class="keyword">this</span>.highWaterMark</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果读取长度小于缓存区长度，this.read(2) highWaterMark=3</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; n &lt;= <span class="keyword">this</span>.len) &#123;</span><br><span class="line">      buffer = Buffer.alloc(n)</span><br><span class="line">      <span class="keyword">let</span> current</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">while</span> (flag &amp;&amp; (current = <span class="keyword">this</span>.arr.shift())) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; current.length; i++) &#123;</span><br><span class="line">          buffer[index++] = current[i]</span><br><span class="line">          <span class="keyword">if</span> (index === n) &#123;</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">let</span> other = current.slice(i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (other.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">this</span>.arr.unshift(other)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.len -= n</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存区长度为0时，表明可以触发readable事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.len === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emitReadable = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存区长度小于水位线时，则进行文件读取</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.len &lt; <span class="keyword">this</span>.highWaterMark) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.reading) &#123;</span><br><span class="line">        <span class="keyword">this</span>.reading = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">this</span>._read()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据编码方式处理数据</span></span><br><span class="line">    <span class="keyword">if</span> (buffer) &#123;</span><br><span class="line">      buffer = <span class="keyword">this</span>.encoding ? buffer.toString(<span class="keyword">this</span>.encoding) : buffer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处如上，省略...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="三-读取长度等于水位线">三、读取长度等于水位线</span></h2><p>当读取长度等于水位线时，使用原生方式调用，可以得到如下结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./1.txt'</span>, &#123;</span><br><span class="line">  autoClose: <span class="literal">true</span>,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  flags: <span class="string">'r'</span>,</span><br><span class="line">  encoding: <span class="string">'utf8'</span>,</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> r = rs.read(<span class="number">2</span>)</span><br><span class="line">  <span class="comment">// 输出结果为 12 34 56 78 90 null</span></span><br><span class="line">  <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>由此可知，如果缓冲区内容读完为空，则返回结果继续读取。实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadableStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处如上，省略...</span></span><br><span class="line"></span><br><span class="line">  read (n) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处如上，省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果读取长度等于水位线，this.len 等于 0，表明可以触发readable事件，固_read后会触发readable函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.len === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emitReadable = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存区长度小于水位线时，则进行文件读取</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.len &lt; <span class="keyword">this</span>.highWaterMark) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.reading) &#123;</span><br><span class="line">        <span class="keyword">this</span>.reading = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">this</span>._read()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处如上，省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处如上，省略...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="四-读取长度大于水位线">四、读取长度大于水位线</span></h2><p>当读取长度大于水位线时，使用原生方式调用，可以得到如下结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./1.txt'</span>, &#123;</span><br><span class="line">  autoClose: <span class="literal">true</span>,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  flags: <span class="string">'r'</span>,</span><br><span class="line">  encoding: <span class="string">'utf8'</span>,</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> r = rs.read(<span class="number">8</span>)</span><br><span class="line">  <span class="comment">// 输出结果为 null 12345678 90</span></span><br><span class="line">  <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>由此可知，如果缓冲区内容不够读，初次会返回 <code>null</code>，然后修改 <code>highWaterMark</code> 值继续读取返回，即为 <code>12345678</code>。此时，<code>this.len</code> 不等于 <code>0</code> 且小于 <code>this.highWaterMark</code>，会再次调用 <code>_read</code> 方法，如果读取文件为空，则需要手动触发一下 <code>readable</code> 事件。实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadableStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处如上，省略...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可读流实例调用的方法</span></span><br><span class="line">  read (n) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处如上，省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果this.read(8) highWaterMark=3 </span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="keyword">this</span>.len) &#123;</span><br><span class="line">      <span class="comment">// 不够读时且文件没有读取完，修改highWaterMark继续读取</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.finished) &#123;</span><br><span class="line">        <span class="keyword">this</span>.highWaterMark = computeNewHighWaterMark(n)</span><br><span class="line">        <span class="keyword">this</span>.reading = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">this</span>.emitReadable = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">this</span>._read()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则直接返回缓存数据</span></span><br><span class="line">        buffer = <span class="keyword">this</span>.arr.shift()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处如上，省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 真实读取文件的方法</span></span><br><span class="line">  _read () &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处如上，省略...</span></span><br><span class="line"></span><br><span class="line">    fs.read(<span class="keyword">this</span>.fd, buffer, <span class="number">0</span>, howMuchToRead, <span class="keyword">this</span>.pos, (err, bytesRead) =&gt; &#123;</span><br><span class="line">      <span class="comment">// bytesRead 为文件读取到的长度</span></span><br><span class="line">      <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处如上，省略...</span></span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// this.len不等于0且小于this.highWaterMark，需要手动触发一下readable事件</span></span><br><span class="line">        <span class="keyword">this</span>.finished = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.len) &#123;</span><br><span class="line">          <span class="keyword">this</span>.emit(<span class="string">'readable'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.emit(<span class="string">'end'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处如上，省略...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>计算 <code>highWaterMark</code> 的函数如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeNewHighWaterMark</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  n--;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">  n++;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/zdddrszj/code/blob/master/stream/readableStream/index.js" target="_blank" rel="noopener">源码</a></p><p>😋😋😋，好了，全部功能已经实现，就到此结束吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-创建可读流&quot;&gt;一、创建可读流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二-读取长度小于水位线&quot;&gt;二、读取长度小于水位线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三-读取长度等于水位线&quot;&gt;三、读取长度等
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ReadableStream" scheme="https://zdddrszj.github.io/h-blog/tags/ReadableStream/"/>
    
  </entry>
  
  <entry>
    <title>实现 CommonJs 规范中的 Require 模块</title>
    <link href="https://zdddrszj.github.io/h-blog/2018/06/25/requireAchieved/"/>
    <id>https://zdddrszj.github.io/h-blog/2018/06/25/requireAchieved/</id>
    <published>2018-06-25T05:22:26.000Z</published>
    <updated>2018-10-07T00:52:49.913Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#一-构造req函数">一、构造req函数</a></li><li><a href="#二-构造module函数">二、构造Module函数</a></li></ul><!-- tocstop --><p>开始之前大家要先熟悉下 <code>node</code> 中常用文件读写，路径操作等 <code>API</code>。</p><blockquote><p>实现思路：我们通过定义一个 <code>req</code> 函数，代替 <code>node</code> 中的 <code>require</code> ，这个函数首先会根据路径参数进行路径解析，找到对应文件；然后判断缓存中是否存在该文件对象，存在则返回，否则创建该文件对象，此时不防通过 <code>new</code> 一个 <code>Module</code> 函数实例来创建；再然后，通过 <code>node</code> 中 <code>fs</code> 模块的 <code>readFileSync</code> 方法加载文件，并把文件内容放在闭包函数中，函数参数有<code>exports</code>、<code>require</code>、<code>module</code>，通过 <code>node</code> 中 <code>vm</code> 模块的 <code>runInThisContext</code> 方法创建一个沙箱环境，同时分别给 <code>exports</code>、<code>require</code>、<code>module</code> 参数赋值并执行，最后缓存模块并通过 <code>module.exports</code> 返回文件内容。</p><h2><span id="一-构造req函数">一、构造req函数</span></h2><p>详细代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">req</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先要根据路径变成一个绝对路径</span></span><br><span class="line">  <span class="keyword">let</span> filename = Module._resolveFilename(path)</span><br><span class="line">  <span class="comment">// 文件路径唯一</span></span><br><span class="line">  <span class="keyword">if</span> (Module._cache[filename]) &#123;</span><br><span class="line">    <span class="comment">// 如果加载过 直接把加载过的结果返回</span></span><br><span class="line">    <span class="keyword">return</span> Module._cache[filename].exports</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过文件名创建一个模块</span></span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename)</span><br><span class="line">  <span class="comment">// 加载模块，根据不同后缀加载不同内容</span></span><br><span class="line">  <span class="built_in">module</span>.load()</span><br><span class="line">  <span class="comment">// 进行模块缓存</span></span><br><span class="line">  Module._cache[filename] = <span class="built_in">module</span></span><br><span class="line">  <span class="comment">// 返回最后的结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2><span id="二-构造module函数">二、构造Module函数</span></h2><p>详细代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 默认模块未加载过</span></span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 模块的绝对路径</span></span><br><span class="line">  <span class="keyword">this</span>.filename = filename</span><br><span class="line">  <span class="comment">// 模块导出的结果</span></span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>路径解析方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Module._resolveFilename = <span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">  p = path.join(__dirname, p)</span><br><span class="line">  <span class="comment">// 如果文件有后缀</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/\.\w+$/</span>.test(p)) &#123;</span><br><span class="line">    <span class="comment">// 添加扩展名</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; Module._extensions.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 拼出一个路径</span></span><br><span class="line">      <span class="keyword">let</span> filePath = p + Module._extensions[i]</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断文件是否存在</span></span><br><span class="line">        fs.accessSync(filePath)</span><br><span class="line">        <span class="comment">// 返回文件路径</span></span><br><span class="line">        <span class="keyword">return</span> filePath</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 如果accessSync方法报错，说明文件不存在，则抛出文件未找到异常</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; Module._extensions.length) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'module not found'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则直接返回文件路径</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Module</code> 函数的主要功能即是 <code>load</code> 方法，如果目标文件是 <code>js</code> 文件，则按照 <code>js</code> 方式加载，如果目标文件是 <code>json</code> 文件，则按照 <code>json</code> 方式加载。详细代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块加载函数</span></span><br><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取到文件名称后缀</span></span><br><span class="line">  <span class="keyword">let</span> extname = path.extname(<span class="keyword">this</span>.filename)</span><br><span class="line">  <span class="comment">// 根据不同后缀读取文件内容</span></span><br><span class="line">  Module._extensions[extname](<span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">// 标记模块已加载</span></span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块缓存对象</span></span><br><span class="line">Module._cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件后缀</span></span><br><span class="line">Module._extensions = [<span class="string">'.js'</span>, <span class="string">'.json'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// json格式文件读取方式</span></span><br><span class="line">Module._extensions[<span class="string">'.json'</span>] = <span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> content = fs.readFileSync(<span class="built_in">module</span>.filename, <span class="string">'utf8'</span>)</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建执行js沙箱环境时需要</span></span><br><span class="line">Module.wrapper = [<span class="string">'(function (exports, require, module)&#123;'</span>, <span class="string">'\n&#125;)'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// js代码拼接</span></span><br><span class="line">Module.wrap = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Module.wrapper[<span class="number">0</span>] + content + Module.wrapper[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js格式文件读取方式</span></span><br><span class="line">Module._extensions[<span class="string">'.js'</span>] = <span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">  <span class="keyword">let</span> content = fs.readFileSync(<span class="built_in">module</span>.filename, <span class="string">'utf8'</span>)</span><br><span class="line">  <span class="comment">// 把文件内容放到闭包函数中</span></span><br><span class="line">  <span class="keyword">let</span> script = Module.wrap(content)</span><br><span class="line">  <span class="comment">// 创建不影响外界上下文的沙箱环境</span></span><br><span class="line">  <span class="keyword">let</span> fn = vm.runInThisContext(script)</span><br><span class="line">  <span class="comment">// 让闭包函数执行，同时给函数中export require module变量赋值</span></span><br><span class="line">  fn.call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>.exports, req, <span class="built_in">module</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了，实现起来是不是很简单，下面测试一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在同级目录下创建test.js</span></span><br><span class="line"><span class="comment">// module.exports = 'Hello World'</span></span><br><span class="line"><span class="keyword">let</span> str = req(<span class="string">'./test'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/zdddrszj/code/blob/master/require/index.js" target="_blank" rel="noopener">源码</a></p><p>好了，到这里全部代码已经给出，就到此为止吧~ 😋😋😋</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-构造req函数&quot;&gt;一、构造req函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二-构造module函数&quot;&gt;二、构造Module函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;p&gt;开始
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="require" scheme="https://zdddrszj.github.io/h-blog/tags/require/"/>
    
  </entry>
  
  <entry>
    <title>Express 简单实现</title>
    <link href="https://zdddrszj.github.io/h-blog/2018/06/22/expressAchieved/"/>
    <id>https://zdddrszj.github.io/h-blog/2018/06/22/expressAchieved/</id>
    <published>2018-06-22T09:11:24.000Z</published>
    <updated>2018-10-07T00:52:49.913Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#一-实现-express-启动服务">一、实现 express 启动服务</a></li><li><a href="#二-实现-express-路由">二、实现 express 路由</a></li><li><a href="#三-实现-express-中间件">三、实现 express 中间件</a></li></ul><!-- tocstop --><p>今天我们利用 <code>node</code> 中的 <code>http</code> 模块实现一个 <code>express</code> 框架。关于 <code>http</code> 模块的使用大家可自行查阅<a href="http://nodejs.cn/api/http.html" target="_blank" rel="noopener">相关文档</a>。</p><h2><span id="一-实现-express-启动服务">一、实现 express 启动服务</span></h2><p>原生 <code>express</code> 启动服务<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line"><span class="keyword">let</span> server = app.listen(<span class="number">3000</span>, <span class="string">'localhost'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`app is listening at http://<span class="subst">$&#123;server.address().address&#125;</span>:<span class="subst">$&#123;server.address().port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>若实现如上功能，首先我们确定的是 <code>express</code> 是一个函数，执行后返回一个 <code>app</code> 函数，且有 <code>listen</code> 方法，我们不如称这个 <code>app</code> 函数为监听函数。实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// app是一个监听函数</span></span><br><span class="line">  <span class="keyword">let</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.end(<span class="string">'hello world'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(app)</span><br><span class="line">    <span class="comment">// arguments就是参数(3000, 'localhost', function () &#123;&#125;)</span></span><br><span class="line">    server.listen(...arguments)</span><br><span class="line">    <span class="keyword">return</span> server</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = createApplication</span><br></pre></td></tr></table></figure></p><h2><span id="二-实现-express-路由">二、实现 express 路由</span></h2><p>原生 <code>express</code> 使用路由<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line">app.get(<span class="string">'/name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'get name'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="string">'localhost'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'app is listening'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>若实现如上功能，我们的 <code>app</code> 监听函数需要实现一个 <code>get</code> 方法，该方法可以把本次调用存储在 <code>app</code> 的路由数组中，当服务启动成功后，监听到匹配的路由时即可调用对应的回调。实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// app是一个监听函数</span></span><br><span class="line">  <span class="keyword">let</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前请求方法</span></span><br><span class="line">    <span class="keyword">let</span> m = req.method.toLocaleLowerCase()</span><br><span class="line">    <span class="comment">// 当前请求路径</span></span><br><span class="line">    <span class="keyword">let</span> &#123; pathname &#125; = url.parse(req.url, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; app.routes.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; path, method, handler &#125; = app.routes[i]</span><br><span class="line">      <span class="comment">// 如果该路由项匹配到当前请求，则执行回调</span></span><br><span class="line">      <span class="keyword">if</span> (path === pathname &amp;&amp; method === m) &#123;</span><br><span class="line">        handler(req, res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储所有的请求，以便监听函数调用</span></span><br><span class="line">  app.routes = []</span><br><span class="line">  app.get = <span class="function"><span class="keyword">function</span> (<span class="params">path, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> layer = &#123;</span><br><span class="line">      path,</span><br><span class="line">      method: <span class="string">'get'</span>,</span><br><span class="line">      handler</span><br><span class="line">    &#125;</span><br><span class="line">    app.routes.push(layer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// app.listen = function () &#123;&#125;</span></span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = createApplication</span><br></pre></td></tr></table></figure></p><p>其他 <code>RESTFUL</code> 方法同理。实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// app是一个监听函数</span></span><br><span class="line">  <span class="keyword">let</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前请求方法</span></span><br><span class="line">    <span class="keyword">let</span> m = req.method.toLocaleLowerCase()</span><br><span class="line">    <span class="comment">// 当前请求路径</span></span><br><span class="line">    <span class="keyword">let</span> &#123; pathname &#125; = url.parse(req.url, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; app.routes.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; path, method, handler &#125; = app.routes[i]</span><br><span class="line">      <span class="comment">// 如果该路由项匹配到当前请求，则执行回调</span></span><br><span class="line">      <span class="keyword">if</span> ((path === pathname || path === <span class="string">'*'</span>) &amp;&amp; (method === m || method === <span class="string">'all'</span>)) &#123;</span><br><span class="line">        handler(req, res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储所有的请求，以便监听函数调用</span></span><br><span class="line">  app.routes = []</span><br><span class="line">  <span class="comment">// http.METHODS 获取RESTFUL所有方法</span></span><br><span class="line">  http.METHODS.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">    method = method.toLocaleLowerCase()</span><br><span class="line">    app[method] = <span class="function"><span class="keyword">function</span> (<span class="params">path, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        path,</span><br><span class="line">        handler</span><br><span class="line">      &#125;</span><br><span class="line">      app.routes.push(layer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 如果没有匹配成功，最终执行all函数所存储的回调</span></span><br><span class="line">  app.all = <span class="function"><span class="keyword">function</span> (<span class="params">path, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> layer = &#123;</span><br><span class="line">      method: <span class="string">'all'</span>, <span class="comment">// 表示全部匹配</span></span><br><span class="line">      path,</span><br><span class="line">      handler</span><br><span class="line">    &#125;</span><br><span class="line">    app.routes.push(layer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// app.listen = function () &#123;&#125;</span></span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = createApplication</span><br></pre></td></tr></table></figure></p><h2><span id="三-实现-express-中间件">三、实现 express 中间件</span></h2><p>原生 <code>express</code> 使用中间件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html; charset=utf-8'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="string">'/name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'/name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'获取姓名'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="string">'localhost'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'app is listening'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>由此可见，<code>use</code> 方法和 <code>method</code> 方法大同小异，重点是实现 <code>next</code> 方法。<br><code>next</code> 函数的作用即是在请求到达前更改一些上下文环境，比如修改返回字符集编码等，且按顺序执行，固可用迭代的方式实现。实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">let</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// app是一个监听函数</span></span><br><span class="line">  <span class="keyword">let</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前请求方法</span></span><br><span class="line">    <span class="keyword">let</span> m = req.method.toLocaleLowerCase()</span><br><span class="line">    <span class="comment">// 当前请求路径</span></span><br><span class="line">    <span class="keyword">let</span> &#123; pathname &#125; = url.parse(req.url, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 迭代次数索引</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 用next代替for循环</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果全部路由数组都不满足，则返回找不到</span></span><br><span class="line">      <span class="keyword">if</span> (index === app.routes.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.end(<span class="string">`can not <span class="subst">$&#123;m&#125;</span> <span class="subst">$&#123;pathname&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理中间件</span></span><br><span class="line">      <span class="keyword">let</span> &#123; method, path, handler &#125; = app.routes[index++]</span><br><span class="line">      <span class="keyword">if</span> (method === <span class="string">'middle'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该中间件path是/，匹配全部请求，执行回调；如果相等，执行回调；如果该中间件path被包含在当前请求url中，也执行回调</span></span><br><span class="line">        <span class="keyword">if</span> (path === <span class="string">'/'</span> || path === pathname || pathname.startsWith(path + <span class="string">'/'</span>)) &#123;</span><br><span class="line">          handler(req, res, next)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          next()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((path === pathname || path === <span class="string">'*'</span>) &amp;&amp; (method === m || method === <span class="string">'all'</span>)) &#123;</span><br><span class="line">          handler(req, res, next)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          next()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接调用next函数，根据路径匹配查找对应回调并执行</span></span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// app.routes = []</span></span><br><span class="line">  <span class="comment">// http.METHODS.forEach(() =&gt; &#123;&#125;</span></span><br><span class="line">  <span class="comment">// app.all = function (path, handler) &#123;&#125;</span></span><br><span class="line">  <span class="comment">// 中间件：参数可以传path，也可以不传，默认'/'</span></span><br><span class="line">  app.use = <span class="function"><span class="keyword">function</span> (<span class="params">path, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handler !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      handler = path</span><br><span class="line">      path = <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> layer = &#123;</span><br><span class="line">      method: <span class="string">'middle'</span>,</span><br><span class="line">      path,</span><br><span class="line">      handler</span><br><span class="line">    &#125;</span><br><span class="line">    app.routes.push(layer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// app.listen = function () &#123;&#125;</span></span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = createApplication</span><br></pre></td></tr></table></figure></p><p>此时，<code>express</code> 的主要功能已经实现，下面来看下如果执行错误通过 <code>next</code> 函数参数进行返回的情况。<br>如果 <code>next</code> 函数有参数，会跳过接下来的所有中间件和路由，直接返回错误参数消息，所以在处理中间件之前要先判断错误情况，并且将错误继续向下传递，只有匹配到有四个参数的回调时才执行。实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// app是一个监听函数</span></span><br><span class="line">  <span class="keyword">let</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略...</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 此处省略...</span></span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        res.end(err)</span><br><span class="line">        <span class="keyword">if</span> (handler.length === <span class="number">4</span>) &#123;</span><br><span class="line">          handler(err, req, res, next)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          next(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理中间件，此处省略...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// app.routes = []</span></span><br><span class="line">  <span class="comment">// http.METHODS.forEach(() =&gt; &#123;&#125;</span></span><br><span class="line">  <span class="comment">// app.all = function (path, handler) &#123;&#125;</span></span><br><span class="line">  <span class="comment">// app.use = function (path, handler) &#123;&#125;</span></span><br><span class="line">  <span class="comment">// app.listen = function () &#123;&#125;</span></span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = createApplication</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/zdddrszj/code/blob/master/express/index.js" target="_blank" rel="noopener">源码</a></p><p>好了，到这里全部代码已经给出，就到此为止吧~ 😋😋😋</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-实现-express-启动服务&quot;&gt;一、实现 express 启动服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二-实现-express-路由&quot;&gt;二、实现 express 路由&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="express" scheme="https://zdddrszj.github.io/h-blog/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Babel 一下 ES6 中的类及继承</title>
    <link href="https://zdddrszj.github.io/h-blog/2018/06/19/classAndInherits/"/>
    <id>https://zdddrszj.github.io/h-blog/2018/06/19/classAndInherits/</id>
    <published>2018-06-19T05:41:16.000Z</published>
    <updated>2018-10-07T00:52:49.912Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#一-用es5实现继承">一、用ES5实现继承</a><ul><li><a href="#1-创建父类">1、创建父类</a></li><li><a href="#2-创建子类并继承">2、创建子类并继承</a></li></ul></li><li><a href="#二-用es6实现继承">二、用es6实现继承</a></li><li><a href="#三-手动实现es6中类及继承">三、手动实现ES6中类及继承</a><ul><li><a href="#1-实现父类">1、实现父类</a></li><li><a href="#2-实现子类及继承">2、实现子类及继承</a></li></ul></li></ul><!-- tocstop --><h2><span id="一-用es5实现继承">一、用ES5实现继承</span></h2><h3><span id="1-创建父类">1、创建父类</span></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'father'</span></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eat'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公有方法</span></span><br><span class="line">Father.prototype.sleep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sleep'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father() <span class="comment">// 此时控制台输出挂载在window对象上的方法，可知没有创建实例时this指向window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> father = <span class="keyword">new</span> Father()</span><br><span class="line">father.eat() <span class="comment">// eat</span></span><br><span class="line">father.sleep() <span class="comment">// sleep</span></span><br><span class="line"><span class="built_in">console</span>.log(father) <span class="comment">// Father &#123; name: 'father', eat: [Function] &#125;</span></span><br></pre></td></tr></table></figure><h3><span id="2-创建子类并继承">2、创建子类并继承</span></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承父类的私有属性和方法</span></span><br><span class="line">  Father.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">// 自己的私有属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'child'</span></span><br><span class="line">  <span class="comment">// 自己的私有方法</span></span><br><span class="line">  <span class="keyword">this</span>.smoke = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'smoke'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承父类的公共方法：将Child的prototype指向Father的prototype，同时修改Child.prototype.constructor为Child本身</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Father.prototype, &#123; <span class="attr">constructor</span>: &#123; </span><br><span class="line">  value: Child,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;&#125;)</span><br><span class="line"><span class="comment">// 修改原型链：将Child的原型链指向所从属的原型上，即Child.__proto__ = Father，或者</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Child, Father)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child()</span><br><span class="line">child.eat() <span class="comment">// eat</span></span><br><span class="line">child.sleep() <span class="comment">// sleep</span></span><br><span class="line">child.smoke() <span class="comment">// smoke</span></span><br><span class="line"><span class="built_in">console</span>.log(Child.__proto__.prototype === Father.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2><span id="二-用es6实现继承">二、用es6实现继承</span></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="comment">// 私有属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'father'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  eat () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eat'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法，可直接访问的私有方法</span></span><br><span class="line">  <span class="keyword">static</span> sleep () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="comment">// 私有属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'child'</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">12</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  smoke () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'smoke'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child()</span><br><span class="line">child.eat() <span class="comment">// eat</span></span><br><span class="line">Child.sleep() <span class="comment">// sleep</span></span><br><span class="line">child.smoke() <span class="comment">// smoke</span></span><br></pre></td></tr></table></figure><h2><span id="三-手动实现es6中类及继承">三、手动实现ES6中类及继承</span></h2><h3><span id="1-实现父类">1、实现父类</span></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为类实例需要new创建，不能直接使用，所以需要一个类调用检查函数，即_classCallCheck函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span> (<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!instance <span class="keyword">instanceof</span> <span class="keyword">constructor</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'cannot call a class as a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类创建函数： Constructor是原型 protoProps是公有方法 staticProps是静态方法，也是私有方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(target, props[i].key, &#123;</span><br><span class="line">        value: props[i].value,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加公有方法</span></span><br><span class="line">  <span class="keyword">if</span> (protoProps) &#123;</span><br><span class="line">    defineProperties(Constructor.prototype, protoProps)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态方法，也是私有方法</span></span><br><span class="line">  <span class="keyword">if</span> (staticProps) &#123;</span><br><span class="line">    defineProperties(Constructor, staticProps)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Constructor</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Father = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 类调用检查</span></span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Father)</span><br><span class="line">    <span class="comment">// 私有属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'father'</span></span><br><span class="line">    <span class="comment">// return &#123;</span></span><br><span class="line">    <span class="comment">//   hobby: 'basketball'</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 下面是实现类，即把公有方法绑定到Father的prototype上，静态方法直接放到Father上</span></span><br><span class="line">  _createClass(Father,[</span><br><span class="line">    &#123;</span><br><span class="line">      key: <span class="string">'eat'</span>,</span><br><span class="line">      value: <span class="function"><span class="keyword">function</span> <span class="title">eat</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'eat'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    &#123;</span><br><span class="line">      key: <span class="string">'sleep'</span>,</span><br><span class="line">      value: <span class="function"><span class="keyword">function</span> <span class="title">sleep</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'sleep'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ])</span><br><span class="line">  <span class="keyword">return</span> Father</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3><span id="2-实现子类及继承">2、实现子类及继承</span></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数作用：继承父类的公共方法和修改原型链</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">'function'</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'super expression must either be null or a function,not'</span> + <span class="keyword">typeof</span> superClass)</span><br><span class="line">  &#125;</span><br><span class="line">  subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">      value: subClass,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (subClass) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf ? <span class="built_in">Object</span>.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Child = <span class="function"><span class="keyword">function</span> (<span class="params">Father</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承父类的公有方法：将Child的prototype指向Father的prototype，同时修改Child.prototype.constructor为Child本身</span></span><br><span class="line">  <span class="comment">// 修改原型链：将Child的原型链指向所从属的原型上，即Child.__proto__ = Father</span></span><br><span class="line">  _inherits(Child, Father)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 类调用检查</span></span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Child)</span><br><span class="line">    <span class="comment">// 继承私有属性</span></span><br><span class="line">    <span class="keyword">let</span> obj = Father.call(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 这里是因为父类函数可以返回一个新对象（见父类注释）</span></span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">      that = obj</span><br><span class="line">    &#125;</span><br><span class="line">    that.name = <span class="string">'Child'</span></span><br><span class="line">    that.age = <span class="number">12</span></span><br><span class="line">    <span class="keyword">return</span> that</span><br><span class="line">  &#125;</span><br><span class="line">  _createClass(Child, [&#123;</span><br><span class="line">    key: <span class="string">'smoking'</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">smoking</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'smoking'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;])</span><br><span class="line">  <span class="keyword">return</span> Child</span><br><span class="line">&#125;(Father)</span><br></pre></td></tr></table></figure><p>好了，到这里介绍完毕~ 😋😋😋</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-用es5实现继承&quot;&gt;一、用ES5实现继承&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-创建父类&quot;&gt;1、创建父类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-创建子类并继承&quot;&gt;2、创建子类并继承&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="es6" scheme="https://zdddrszj.github.io/h-blog/tags/es6/"/>
    
      <category term="class" scheme="https://zdddrszj.github.io/h-blog/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>3D 时钟</title>
    <link href="https://zdddrszj.github.io/h-blog/2018/01/08/3DClock/"/>
    <id>https://zdddrszj.github.io/h-blog/2018/01/08/3DClock/</id>
    <published>2018-01-08T08:39:05.000Z</published>
    <updated>2018-10-07T00:52:49.912Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们利用 <code>canvas</code> 和 <code>threejs</code> 基础知识来做一个可以旋转的 3D 时钟动效。效果如下：</p><p><img src="http://zdddrszj.github.io/h5case/3DClock/3DClock.gif" alt="3DClock"></p><blockquote><p><code>threejs</code> 基础概念大家需要提前了解一下。</p></blockquote><h3><span id="一-制作时钟">一、制作时钟</span></h3><h4><span id="1-基础变量定义">1、基础变量定义</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestAnimationFrame = requestAnimationFrame || webkitRequestAnimationFrame || oRequestAnimationFrame || msRequestAnimationFrame</span><br><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>),</span><br><span class="line">    ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">    canvas.setAttribute(<span class="string">'width'</span>, <span class="number">400</span>)</span><br><span class="line">    canvas.setAttribute(<span class="string">'height'</span>, <span class="number">400</span>)</span><br><span class="line"><span class="comment">// 刻画时钟</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clock</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">400</span>)</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">        hours = date.getHours(),</span><br><span class="line">        minutes = date.getMinutes(),</span><br><span class="line">        seconds = date.getSeconds()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环调用</span></span><br><span class="line">    requestAnimationFrame(clock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="2-画时钟边框">2、画时钟边框</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个从上到下的漂亮颜色渐变</span></span><br><span class="line"><span class="keyword">let</span> gradient = ctx.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">gradient.addColorStop(<span class="number">0</span>, <span class="string">'#48d5ae'</span>)</span><br><span class="line">gradient.addColorStop(<span class="number">1</span>, <span class="string">'#249ec2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画时钟边框</span></span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.lineWidth = <span class="number">10</span></span><br><span class="line">ctx.strokeStyle = gradient</span><br><span class="line">ctx.arc(<span class="number">200</span>, <span class="number">200</span>, <span class="number">195</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI)</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br></pre></td></tr></table></figure><h4><span id="3-画分针刻度">3、画分针刻度</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath()</span><br><span class="line">ctx.lineWidth = <span class="number">5</span></span><br><span class="line">ctx.strokeStyle = <span class="string">'#9c9ba0'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 保存画布当前状态，对画布进行变换时需要save restore，否则影响后面画布上的元素</span></span><br><span class="line">    ctx.save()</span><br><span class="line">    <span class="comment">// 移动画布，将坐标原点放在时钟中心点</span></span><br><span class="line">    ctx.translate(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">    <span class="comment">// 旋转画布，每次旋转6度，60次旋转一周</span></span><br><span class="line">    ctx.rotate(i * <span class="number">6</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>)</span><br><span class="line">    <span class="comment">// 12点方向</span></span><br><span class="line">    ctx.moveTo(<span class="number">0</span>, <span class="number">-180</span>)</span><br><span class="line">    ctx.lineTo(<span class="number">0</span>, <span class="number">-190</span>)</span><br><span class="line">    <span class="comment">// 恢复画布之前的状态</span></span><br><span class="line">    ctx.restore()</span><br><span class="line">&#125;</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br></pre></td></tr></table></figure><h4><span id="4-画时针刻度">4、画时针刻度</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath()</span><br><span class="line">ctx.lineWidth = <span class="number">8</span></span><br><span class="line">ctx.strokeStyle = <span class="string">'#535257'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 保存画布当前状态，对画布进行变换时需要save restore，否则影响后面画布上的元素</span></span><br><span class="line">    ctx.save()</span><br><span class="line">    <span class="comment">// 移动画布，将坐标原点放在时钟中心点</span></span><br><span class="line">    ctx.translate(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">    <span class="comment">// 旋转画布，每次旋转30度，12次旋转一周</span></span><br><span class="line">    ctx.rotate(i * <span class="number">30</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>)</span><br><span class="line">    <span class="comment">// 12点方向</span></span><br><span class="line">    ctx.moveTo(<span class="number">0</span>, <span class="number">-170</span>)</span><br><span class="line">    ctx.lineTo(<span class="number">0</span>, <span class="number">-190</span>)</span><br><span class="line">    <span class="comment">// 恢复画布之前的状态</span></span><br><span class="line">    ctx.restore()</span><br><span class="line">&#125;</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br></pre></td></tr></table></figure><h4><span id="5-画时间点">5、画时间点</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath()</span><br><span class="line">ctx.save()</span><br><span class="line">ctx.translate(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">ctx.font = <span class="string">'26px Arial'</span></span><br><span class="line">ctx.textAlign = <span class="string">'center'</span></span><br><span class="line">ctx.textBaseline = <span class="string">'middle'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; <span class="number">12</span>; n++) &#123;</span><br><span class="line">    <span class="comment">// n * (Math.PI * 2) / 12 代表3点</span></span><br><span class="line">    <span class="keyword">var</span> theta = (n - <span class="number">2</span>) * (<span class="built_in">Math</span>.PI * <span class="number">2</span>) / <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">150</span> * <span class="built_in">Math</span>.cos(theta);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">150</span> * <span class="built_in">Math</span>.sin(theta);</span><br><span class="line">    ctx.fillText(n + <span class="number">1</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line">ctx.restore()</span><br><span class="line">ctx.closePath()</span><br></pre></td></tr></table></figure><h4><span id="6-画时针">6、画时针</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath()</span><br><span class="line">ctx.save()</span><br><span class="line">ctx.lineWidth = <span class="number">7</span></span><br><span class="line">ctx.strokeStyle = <span class="string">'#38383b'</span></span><br><span class="line">ctx.translate(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment">// 每小时30度</span></span><br><span class="line">ctx.rotate(hours % <span class="number">12</span> * <span class="number">30</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>)</span><br><span class="line">ctx.moveTo(<span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// 12点方向</span></span><br><span class="line">ctx.lineTo(<span class="number">0</span>, <span class="number">-80</span>)</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.restore()</span><br><span class="line">ctx.closePath()</span><br></pre></td></tr></table></figure><h4><span id="7-画分针">7、画分针</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath()</span><br><span class="line">ctx.save()</span><br><span class="line">ctx.lineWidth = <span class="number">5</span></span><br><span class="line">ctx.translate(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment">// 每分钟6度</span></span><br><span class="line">ctx.rotate(minutes * <span class="number">6</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>)</span><br><span class="line">ctx.moveTo(<span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// 12点方向</span></span><br><span class="line">ctx.lineTo(<span class="number">0</span>, <span class="number">-110</span>)</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.restore()</span><br><span class="line">ctx.closePath()</span><br></pre></td></tr></table></figure><h4><span id="8-画秒针">8、画秒针</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath()</span><br><span class="line">ctx.save()</span><br><span class="line">ctx.lineWidth = <span class="number">3</span></span><br><span class="line">ctx.strokeStyle = <span class="string">'#FD3351'</span></span><br><span class="line">ctx.translate(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment">// 每秒钟6度</span></span><br><span class="line">ctx.rotate(seconds * <span class="number">6</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>)</span><br><span class="line">ctx.moveTo(<span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// 12点方向</span></span><br><span class="line">ctx.lineTo(<span class="number">0</span>, <span class="number">-130</span>)</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.restore()</span><br><span class="line">ctx.closePath()</span><br></pre></td></tr></table></figure><h4><span id="9-画时钟圆心">9、画时钟圆心</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath()</span><br><span class="line">ctx.fillStyle = <span class="string">'#edb052'</span></span><br><span class="line">ctx.arc(<span class="number">200</span>, <span class="number">200</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI)</span><br><span class="line">ctx.fill()</span><br><span class="line">ctx.closePath()</span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.fillStyle = <span class="string">'#ff364e'</span></span><br><span class="line">ctx.arc(<span class="number">200</span>, <span class="number">200</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI)</span><br><span class="line">ctx.fill()</span><br><span class="line">ctx.closePath()</span><br></pre></td></tr></table></figure><p><g-emoji alias="innocent" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f607.png" ios-version="6.0">😇</g-emoji> 到此时钟刻画完毕。</p><h3><span id="二-添加动画">二、添加动画</span></h3><p>这里需要大家提前查阅资料了解 <code>渲染器</code> <code>场景</code> <code>相机</code> <code>模型</code> <code>几何体</code> <code>材料</code> <code>纹理</code> 几个名词的概念。</p><blockquote><p>附上我简单鄙陋的理解：渲染器可以将场景渲染出来。场景由模型构建。相机有透视相机和正交相机之分，在不同角度不同相机的照射下场景会展示出不同的效果。模型由几何体组成。几何体由材料填充。材料由纹理修饰，纹理可以是图片，也可以是画布。</p></blockquote><p>js 代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义变量：渲染器 场景 相机 模型 几何体 材料 纹理</span></span><br><span class="line"><span class="keyword">var</span> renderer, scene, camera,  mesh, geometry, material, texture</span><br><span class="line"><span class="comment">// 页面入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义时钟</span></span><br><span class="line">    clock()</span><br><span class="line">    <span class="comment">// 定义 3D 场景</span></span><br><span class="line">    init()</span><br><span class="line">    <span class="comment">// 定义动画</span></span><br><span class="line">    animate()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建渲染对象</span></span><br><span class="line">    renderer = <span class="keyword">new</span> THREE.WebGLRenderer()</span><br><span class="line">    renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(renderer.domElement)</span><br><span class="line">    <span class="comment">// 创建透视相机</span></span><br><span class="line">    camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">70</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">    camera.position.z = <span class="number">600</span></span><br><span class="line">    <span class="comment">// 创建场景对象</span></span><br><span class="line">    scene = <span class="keyword">new</span> THREE.Scene()</span><br><span class="line">    <span class="comment">// 创建几何体对象</span></span><br><span class="line">    <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.CubeGeometry(<span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">    <span class="comment">// 创建纹理（即时钟）</span></span><br><span class="line">    texture = <span class="keyword">new</span> THREE.Texture(canvas)</span><br><span class="line">    <span class="comment">// 将纹理传递给材质</span></span><br><span class="line">    material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">map</span>: texture &#125;)</span><br><span class="line">    texture.needsUpdate = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 创建模型</span></span><br><span class="line">    mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material)</span><br><span class="line">    <span class="comment">// 将模型添加到场景</span></span><br><span class="line">    scene.add(mesh)</span><br><span class="line">    renderer.clear()</span><br><span class="line">    <span class="comment">// 场景渲染</span></span><br><span class="line">    renderer.render(scene, camera)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    texture.needsUpdate = <span class="literal">true</span></span><br><span class="line">    mesh.rotation.y -= <span class="number">0.01</span></span><br><span class="line">    mesh.rotation.x -= <span class="number">0.01</span></span><br><span class="line">    requestAnimationFrame(animate)</span><br><span class="line">    renderer.clear()</span><br><span class="line">    renderer.render(scene, camera)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 起始函数调用</span></span><br><span class="line">start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resize</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    camera.aspect = <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight</span><br><span class="line">    camera.updateProjectionMatrix()</span><br><span class="line">    renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, resize)</span><br></pre></td></tr></table></figure></p><p>终于大功告成！</p><p><a href="http://zdddrszj.github.io/h5case/3DClock/index.html">查看demo</a></p><p><g-emoji alias="yum" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60b.png" ios-version="6.0">😋</g-emoji><g-emoji alias="yum" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60b.png" ios-version="6.0">😋</g-emoji><g-emoji alias="yum" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60b.png" ios-version="6.0">😋</g-emoji></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们利用 &lt;code&gt;canvas&lt;/code&gt; 和 &lt;code&gt;threejs&lt;/code&gt; 基础知识来做一个可以旋转的 3D 时钟动效。效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zdddrszj.github.io/h5case/3DClock/3
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="canvas" scheme="https://zdddrszj.github.io/h-blog/tags/canvas/"/>
    
      <category term="threejs" scheme="https://zdddrszj.github.io/h-blog/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>点线图动画</title>
    <link href="https://zdddrszj.github.io/h-blog/2017/10/17/dotsAndLineAni/"/>
    <id>https://zdddrszj.github.io/h-blog/2017/10/17/dotsAndLineAni/</id>
    <published>2017-10-17T11:08:32.000Z</published>
    <updated>2018-06-23T08:19:44.892Z</updated>
    
    <content type="html"><![CDATA[<p>世界浩瀚无边，然而都是由粒子组成；一句老话复杂的东西都是由简单的东西组成。</p><p>本文主题是一个大家经常看到的点线图简单动画，即下图，所以直接来代码吧！</p><p><img src="http://zdddrszj.github.io/h5case/DotAndLineAni/dotAndLineAni.gif" alt="dotAndLineAni"></p><p>首先声明一些 <code>js</code> 变量（这些变量不用提前知晓，进入画图逻辑时自然知道需要声明哪些变量）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画布上所有点对象数组</span></span><br><span class="line"><span class="keyword">let</span> dotsArr = [],</span><br><span class="line">   canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>),</span><br><span class="line">   ctx = canvas.getContext(<span class="string">'2d'</span>),</span><br><span class="line">   width = <span class="built_in">document</span>.documentElement.offsetWidth || <span class="built_in">document</span>.body.offsetWidth,</span><br><span class="line">   height = <span class="built_in">document</span>.documentElement.offsetHeight || <span class="built_in">document</span>.documentElement.offsetHeight,</span><br><span class="line">   <span class="comment">// 画布点的数量</span></span><br><span class="line">   dotsNum = <span class="built_in">parseInt</span>(width * height / <span class="number">8000</span>),</span><br><span class="line">   <span class="comment">// 两个点可以连线的间距临界值</span></span><br><span class="line">   dotsDistance = <span class="number">100</span></span><br><span class="line">   <span class="comment">// 画布点最大数量</span></span><br><span class="line">   maxDotsNum = dotsNum * <span class="number">1.5</span></span><br><span class="line">   <span class="comment">// 多出的点数量</span></span><br><span class="line">   overDotsNum = <span class="number">0</span></span><br><span class="line">   <span class="comment">// 设置画布大小（注意：这里不能用style代替）</span></span><br><span class="line">   canvas.setAttribute(<span class="string">'width'</span>, width)</span><br><span class="line">   canvas.setAttribute(<span class="string">'height'</span>, height)</span><br></pre></td></tr></table></figure></p><p>html结构<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3><span id="一-画点">一、画点</span></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.canvas</span><br><span class="line">    <span class="keyword">this</span>.ctx</span><br><span class="line">    <span class="comment">// x轴坐标</span></span><br><span class="line">    <span class="keyword">this</span>.x</span><br><span class="line">    <span class="comment">// y轴坐标</span></span><br><span class="line">    <span class="keyword">this</span>.y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点初始化方法</span></span><br><span class="line">Dot.prototype = &#123;</span><br><span class="line">init: <span class="function"><span class="keyword">function</span> (<span class="params">canvas, x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.canvas = canvas</span><br><span class="line">        <span class="keyword">this</span>.ctx = <span class="keyword">this</span>.canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">        <span class="comment">// 随机x轴坐标</span></span><br><span class="line">        <span class="keyword">this</span>.x = x || <span class="built_in">Math</span>.random() * <span class="keyword">this</span>.canvas.width</span><br><span class="line">        <span class="comment">// 随机y轴坐标</span></span><br><span class="line">        <span class="keyword">this</span>.y = y || <span class="built_in">Math</span>.random() * <span class="keyword">this</span>.canvas.height</span><br><span class="line">        <span class="comment">// 随机半径</span></span><br><span class="line">        <span class="keyword">this</span>.r = <span class="built_in">Math</span>.random() * <span class="number">4</span></span><br><span class="line">        <span class="comment">// 随机水平速度</span></span><br><span class="line">        <span class="keyword">this</span>.vx = <span class="built_in">Math</span>.random() * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">        <span class="comment">// 随机垂直速度</span></span><br><span class="line">        <span class="keyword">this</span>.vy = <span class="built_in">Math</span>.random() * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">        <span class="comment">// 画个实心点</span></span><br><span class="line">        <span class="keyword">this</span>.ctx.beginPath()</span><br><span class="line">        <span class="keyword">this</span>.ctx.arc(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.r, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI)</span><br><span class="line">        <span class="keyword">this</span>.ctx.fillStyle = <span class="string">"rgba(255, 255, 255, .8)"</span></span><br><span class="line">        <span class="keyword">this</span>.ctx.fill()</span><br><span class="line">        <span class="keyword">this</span>.ctx.closePath()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机生成一定数量的点，画到画布上的同时，将其存储在dotsArr数组中，更新画布时用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; dotsNum; i ++) &#123;</span><br><span class="line">    <span class="keyword">var</span> dot = <span class="keyword">new</span> Dot()</span><br><span class="line">    dotsArr.push(dot)</span><br><span class="line">    dot.init(canvas)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="二-画线及动效">二、画线及动效</span></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestAnimationFrame = requestAnimationFrame || webkitRequestAnimationFrame || oRequestAnimationFrame || msRequestAnimationFrame</span><br><span class="line">requestAnimationFrame(updateCanvas)</span><br><span class="line"><span class="comment">// 更新画布</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCanvas</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 清空画布</span></span><br><span class="line">    ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height)</span><br><span class="line">    <span class="comment">// 点的个数为 dotsNum ~ dotsNum，即 0 ~ dotsNum 或者 (dotsNum - maxDotsNum) ~ dotsNum</span></span><br><span class="line">    <span class="keyword">if</span> (dotsNum &gt; maxDotsNum) &#123;</span><br><span class="line">        overDotsNum = dotsNum - maxDotsNum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = overDotsNum; j &lt; dotsNum; j ++) &#123;</span><br><span class="line">    <span class="comment">// 更新点坐标</span></span><br><span class="line">        dotsArr[j].update()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> m = overDotsNum; m &lt; dotsNum; m ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> n = m + <span class="number">1</span>; n &lt; dotsNum; n ++) &#123;</span><br><span class="line">            <span class="keyword">let</span> dx = dotsArr[m].x - dotsArr[n].x</span><br><span class="line">            <span class="keyword">let</span> dy = dotsArr[m].y - dotsArr[n].y</span><br><span class="line">            <span class="comment">// 两个点之间的距离</span></span><br><span class="line">            <span class="keyword">let</span> d = <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(dx, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(dy, <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> (d &lt; dotsDistance) &#123;</span><br><span class="line">                ctx.beginPath()</span><br><span class="line">                ctx.moveTo(dotsArr[m].x, dotsArr[m].y)</span><br><span class="line">                ctx.lineTo(dotsArr[n].x, dotsArr[n].y)</span><br><span class="line">                ctx.strokeStyle = <span class="string">'rgba(255, 255, 255, '</span> + (dotsDistance - d) / dotsDistance + <span class="string">')'</span></span><br><span class="line">                ctx.strokeWidth = <span class="number">1</span></span><br><span class="line">                ctx.stroke()</span><br><span class="line">                ctx.closePath()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新渲染画布</span></span><br><span class="line">    requestAnimationFrame(updateCanvas)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新点坐标</span></span><br><span class="line">Dot.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 获取此时该点坐标</span></span><br><span class="line"><span class="keyword">this</span>.x = <span class="keyword">this</span>.x + <span class="keyword">this</span>.vx</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="keyword">this</span>.y + <span class="keyword">this</span>.vy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点越界后调用init重新随机生成 因为点的个数固定，屏幕实时绘制，所以移出屏幕的点对象不用考虑占内存之类的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.x &lt; <span class="number">0</span> || <span class="keyword">this</span>.x &gt; <span class="keyword">this</span>.canvas.width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.init(<span class="keyword">this</span>.canvas)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.y &lt; <span class="number">0</span> || <span class="keyword">this</span>.y &gt; <span class="keyword">this</span>.canvas.height) &#123;</span><br><span class="line">        <span class="keyword">this</span>.init(<span class="keyword">this</span>.canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.ctx.beginPath()</span><br><span class="line">    <span class="keyword">this</span>.ctx.arc(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.r, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI)</span><br><span class="line">    <span class="keyword">this</span>.ctx.fillStyle = <span class="string">"rgba(255,255,255,.8)"</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.fill()</span><br><span class="line">    <span class="keyword">this</span>.ctx.closePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里基本功能已经完成，下边介绍一下鼠标点击和移动事件的动效。</p><h3><span id="三-鼠标点击事件">三、鼠标点击事件</span></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件绑定</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, handleClick)</span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = e.pageX</span><br><span class="line">    <span class="keyword">let</span> y = e.pageY</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j ++) &#123;</span><br><span class="line">        dotsNum ++</span><br><span class="line">        <span class="keyword">var</span> dot = <span class="keyword">new</span> Dot()</span><br><span class="line">        dotsArr.push(dot)</span><br><span class="line">        dot.init(canvas, x, y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="四-鼠标移动事件">四、鼠标移动事件</span></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件绑定</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, handleMousemove)</span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMousemove</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = e.pageX,</span><br><span class="line">        y = e.pageY</span><br><span class="line">    <span class="keyword">if</span> ((x &gt; <span class="number">0</span> &amp;&amp; x &lt; width) &amp;&amp; (y &gt; <span class="number">0</span> &amp;&amp; y &lt; height)) &#123;</span><br><span class="line">        <span class="comment">// dot为画布上最后画的最后一个点</span></span><br><span class="line">        dot.followMouse(x, y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 鼠标跟随及重新定义点的坐标</span></span><br><span class="line">Dot.prototype.followMouse = <span class="function"><span class="keyword">function</span> (<span class="params">tx, ty</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = tx</span><br><span class="line">    <span class="keyword">this</span>.y = ty</span><br><span class="line">    <span class="keyword">this</span>.ctx.beginPath()</span><br><span class="line">    <span class="keyword">this</span>.ctx.arc(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.r, <span class="number">0</span>, <span class="number">2</span>*<span class="built_in">Math</span>.PI)</span><br><span class="line">    <span class="keyword">this</span>.ctx.fillStyle = <span class="string">"rgba(255,0,0,.8)"</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.fill()</span><br><span class="line">    <span class="keyword">this</span>.ctx.closePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><g-emoji alias="yum" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60b.png" ios-version="6.0">😋</g-emoji><g-emoji alias="yum" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60b.png" ios-version="6.0">😋</g-emoji><g-emoji alias="yum" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60b.png" ios-version="6.0">😋</g-emoji> 好了，到此就结束啦~</p><p><a href="http://zdddrszj.github.io/h5case/DotAndLineAni/dotAndLineAni.html">查看demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;世界浩瀚无边，然而都是由粒子组成；一句老话复杂的东西都是由简单的东西组成。&lt;/p&gt;
&lt;p&gt;本文主题是一个大家经常看到的点线图简单动画，即下图，所以直接来代码吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zdddrszj.github.io/h5case/DotAnd
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="canvas" scheme="https://zdddrszj.github.io/h-blog/tags/canvas/"/>
    
      <category term="html5" scheme="https://zdddrszj.github.io/h-blog/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>Canvas 多球碰撞和反弹</title>
    <link href="https://zdddrszj.github.io/h-blog/2017/09/27/bounce-and-collision/"/>
    <id>https://zdddrszj.github.io/h-blog/2017/09/27/bounce-and-collision/</id>
    <published>2017-09-27T06:01:14.000Z</published>
    <updated>2018-06-23T08:19:44.891Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#一-矢量移动">一、矢量移动</a></li><li><a href="#二-多球撞墙反弹">二、多球撞墙反弹</a><ul><li><a href="#第一个问题多球沿矢量运动">第一个问题：多球沿矢量运动</a></li><li><a href="#第二个问题如何反弹">第二个问题：如何反弹</a></li></ul></li></ul><!-- tocstop --><p>现实世界中万千万物都有其独自的运行轨迹，例如直线、圆、螺旋和复杂的贝塞尔曲线。今天我们一起来学习一下如何用 <code>Canvas</code> 实现最平凡的直线运动。<code>Canvas</code> 画图基础知识可参考 <a href="http://www.w3school.com.cn/html5/html_5_canvas.asp" target="_blank" rel="noopener">w3school 在线教程</a> 。</p><h3><span id="一-矢量移动">一、矢量移动</span></h3><p>要想为图像设置动画效果，可以采用每次为对象绘制不同的 <code>x</code> 坐标和 <code>y</code> 坐标，然后在每一帧中调用显示更新图像的函数即可。初始化起始点代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = &#123;<span class="attr">x</span>:<span class="number">20</span>,<span class="attr">y</span>:<span class="number">20</span>&#125;; <span class="comment">//初始点坐标</span></span><br><span class="line"><span class="keyword">var</span> ball = &#123;<span class="attr">x</span>:p1.x,<span class="attr">y</span>:p1.y,<span class="attr">radius</span>:<span class="number">10</span>&#125;; <span class="comment">//小球初始坐标及半径</span></span><br></pre></td></tr></table></figure><p>在两点之间移动很方便，但是很多时候并没有一个要移到哪里去的目标点，只有从哪里开始的起始点。这种情况下，创建一个 <code>vector</code> 作为移动对象就非常有用了。</p><p>矢量是一个具有数量和方向的物理量。数量就是对象移动的速度 <code>speed</code> 的值，方向就是对象移动的角度 <code>angle</code> 的值。现在，将对象移动的角度 <code>angle</code> 的值（方向）设为 <code>45°</code>，在数学上，平滑直线通常代表角度为 <code>0</code> ，<code>45°</code> 的矢量就意味着向右下方移动。</p><p>弧度 <code>radians</code> 是度量角度的标准单位，大部分数学计算都需要将角度转换为弧度才能使用。将角度转为弧度，使用标准方程式 <code>radians = angle * Math.PI/180</code> 即可。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> angle = <span class="number">45</span>; <span class="comment">//角度</span></span><br><span class="line"><span class="keyword">var</span> radians = angle * <span class="built_in">Math</span>.PI/<span class="number">180</span>; <span class="comment">//弧度</span></span><br></pre></td></tr></table></figure><p>计算对象沿矢量运动时的坐标值，请看下面简略2D坐标图：</p><p><img src="https://cloud.githubusercontent.com/assets/9649921/13239696/2de0e6e6-da17-11e5-8d5b-3f131eca04f5.png" alt="1"></p><p>可以看出，余弦通常与 <code>x</code> 值有关，正弦通常与 <code>y</code> 值有关，可以利用 <code>sin</code> 和 <code>cos</code> 来计算对象沿矢量的移动。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> speed = <span class="number">5</span>; <span class="comment">//速度</span></span><br><span class="line"><span class="keyword">var</span> xunits = <span class="built_in">Math</span>.cos(radians) * speed; <span class="comment">//x坐标增量</span></span><br><span class="line"><span class="keyword">var</span> yunits = <span class="built_in">Math</span>.sin(radians) * speed;  <span class="comment">//y坐标增量</span></span><br></pre></td></tr></table></figure><p>在渲染画布 <code>drawScreen()</code> 函数中，将 <code>ball.x</code> 和 <code>ball.y</code> 分别加上 <code>xunits</code> 和 <code>yunits</code> ，即可随时更新小球位置坐标点。</p><p><code>drawScreen()</code> 函数详细如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//渲染画布</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawScreen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    context.fillStyle = <span class="string">'#eee'</span>;</span><br><span class="line">    context.fillRect(<span class="number">0</span>,<span class="number">0</span>,theCanvas.width,theCanvas.height);</span><br><span class="line">    context.strokeRect(<span class="number">1</span>,<span class="number">1</span>,theCanvas.width<span class="number">-2</span>,theCanvas.height<span class="number">-2</span>);</span><br><span class="line">    context.fillStyle = <span class="string">'red'</span>;</span><br><span class="line"></span><br><span class="line">    ball.x += xunits;</span><br><span class="line">    ball.y += yunits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小球撞墙检测</span></span><br><span class="line">    <span class="keyword">if</span>(ball.x+ball.radius &gt; theCanvas.width)&#123;</span><br><span class="line">        ball = &#123;<span class="attr">x</span>:p1.x,<span class="attr">y</span>:p1.y,<span class="attr">radius</span>:<span class="number">10</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc(ball.x,ball.y,ball.radius,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="literal">true</span>);</span><br><span class="line">    context.closePath();</span><br><span class="line">    context.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>框架 <code>javascript</code> 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>,eventWindowLoaded,<span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventWindowLoaded</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    canvasApp();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断浏览器是否支持canvas标签</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canvasSupport</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !!<span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>).getContext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canvasApp</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!canvasSupport())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化   代码省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> theCanvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvasOne'</span>);</span><br><span class="line">    <span class="keyword">var</span> context = theCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//渲染画布   代码省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timeOut = setInterval(drawScreen,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>html</code> 代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position:absolute;top:50px;left:50px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvasOne"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">        该浏览器不支持canvas。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终实现效果如下：</p><p><img src="https://cloud.githubusercontent.com/assets/9649921/13216469/e75cbd06-d996-11e5-8264-c437ca18a3ff.gif" alt="jdfw"></p><p><a href="http://yixunfe.github.io/blog/demo/57/demo.html" target="_blank" rel="noopener">查看demo</a></p><h3><span id="二-多球撞墙反弹">二、多球撞墙反弹</span></h3><p>尽管创建一个有数量、有方向的矢量并让对象沿着它精确移动看起来很有动画感，但是现实中却很少出现类似的运动。大部分时候，人们会希望这个对象能对周围的世界有反应，例如撞上水平或者垂直的墙后能弹回来。</p><p>根据第一小节的学习，我们知道一个球如何沿矢量运动，那么多球撞墙反弹需要解决两个问题，分别是多球沿矢量运动和如何反弹。</p><h4><span id="第一个问题多球沿矢量运动">第一个问题：多球沿矢量运动</span></h4><p>为实现多球应用程序，需要创建一个新的对象来控制关于每个反弹球的所有相关信息：<code>x、y、 radius、speed、angle、radians、xunits、yunits</code> 。这里假设我们要创建100个这样的随机小球，给予不同的速度，半径和矢量，如果用代码表示，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义球数量</span></span><br><span class="line"><span class="keyword">var</span> numBalls = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//球最大半径 最小半径</span></span><br><span class="line"><span class="keyword">var</span> maxSize = <span class="number">6</span>,minSize = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//定义球最大速度</span></span><br><span class="line"><span class="keyword">var</span> maxspeed=maxSize+<span class="number">5</span>;</span><br><span class="line"><span class="comment">//球对象数组</span></span><br><span class="line"><span class="keyword">var</span> balls = [];</span><br><span class="line"><span class="comment">// 当前球 x坐标 y坐标 速度 角度 半径 弧度 x方向增量 y方向增量</span></span><br><span class="line"><span class="keyword">var</span> tempBall,tempX,tempY,tempSpeed,tempAngle,tempRadius,tempRadians,tempXunits,tempYunits;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化100个球</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; numBalls; i ++)&#123;</span><br><span class="line">    tempRadius = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*maxSize)+minSize;</span><br><span class="line">    tempX = tempRadius + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(theCanvas.width - tempRadius*<span class="number">2</span>));</span><br><span class="line">    tempY = tempRadius + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(theCanvas.height - tempRadius*<span class="number">2</span>));</span><br><span class="line">    tempSpeed = maxspeed - tempRadius;</span><br><span class="line">    tempAngle = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">360</span>);</span><br><span class="line">    tempRadians = tempAngle * <span class="built_in">Math</span>.PI/<span class="number">180</span>;</span><br><span class="line">    tempXunits = <span class="built_in">Math</span>.cos(tempRadians) * tempSpeed;</span><br><span class="line">    tempYunits = <span class="built_in">Math</span>.sin(tempRadians) * tempSpeed;</span><br><span class="line"></span><br><span class="line">    tempBall = &#123;<span class="attr">x</span>:tempX,<span class="attr">y</span>:tempY,<span class="attr">radius</span>:tempRadius,<span class="attr">speed</span>:tempSpeed,<span class="attr">angle</span>:tempAngle,<span class="attr">radians</span>:tempRadians,<span class="attr">xunits</span>:tempXunits,<span class="attr">yunits</span>:tempYunits&#125;;</span><br><span class="line">    balls.push(tempBall);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="第二个问题如何反弹">第二个问题：如何反弹</span></h4><p>为了更好理解反弹动画，先来看一个简单的物理原理。这条原理经常用于光线上，但对于动画2D形状也非常有用，特别是对象撞上水平或垂直的墙反弹的情况。这个原理就是 <strong>反射角原理</strong>，即入射角等于反射角。</p><p>入射角是对象撞墙时的角度，反射角是对象从墙面反弹回来的角度。如下图所示：</p><p><img src="https://cloud.githubusercontent.com/assets/9649921/13242615/971719e0-da31-11e5-9ddd-888dc8878cf7.png" alt="2"></p><p>由此可知，<code>反弹角 = 180 - 入射角</code>。</p><p> <code>javascript</code> 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ball.x 代表小球 x 坐标 ball.y 代表小球 y 坐标</span></span><br><span class="line"><span class="keyword">if</span>(ball.x+ball.radius &gt; theCanvas.width || ball.x-ball.radius &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    ball.angle = <span class="number">180</span> - ball.angle;</span><br><span class="line">    updateBall(ball);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ball.y+ball.radius &gt; theCanvas.height || ball.y-ball.radius &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    ball.angle = <span class="number">360</span> - ball.angle;</span><br><span class="line">    updateBall(ball);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateBall(ball)</code> 函数详细如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateBall</span>(<span class="params">ball</span>)</span>&#123;</span><br><span class="line">     ball.radians = ball.angle * <span class="built_in">Math</span>.PI/<span class="number">180</span>;</span><br><span class="line">     ball.xunits = <span class="built_in">Math</span>.cos(ball.radians)*ball.speed;</span><br><span class="line">     ball.yunits = <span class="built_in">Math</span>.sin(ball.radians)*ball.speed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，主要代码已经全部给出，最终实现的效果如图：</p><p><img src="https://cloud.githubusercontent.com/assets/9649921/13243052/18f53678-da36-11e5-8a84-b9bbf2d04e84.gif" alt="jdfw"></p><p><a href="http://yixunfe.github.io/blog/demo/57/demo1.html" target="_blank" rel="noopener">查看demo</a></p><p><g-emoji alias="yum" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60b.png" ios-version="6.0">😋</g-emoji><g-emoji alias="yum" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60b.png" ios-version="6.0">😋</g-emoji><g-emoji alias="yum" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60b.png" ios-version="6.0">😋</g-emoji>  好了，今天就到这里吧~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-矢量移动&quot;&gt;一、矢量移动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二-多球撞墙反弹&quot;&gt;二、多球撞墙反弹&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#第一个问题多球沿矢量运动&quot;&gt;第一个问题：多球沿矢量运动&lt;/
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="canvas" scheme="https://zdddrszj.github.io/h-blog/tags/canvas/"/>
    
      <category term="html5" scheme="https://zdddrszj.github.io/h-blog/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>移动端 H5 页面优化（一）</title>
    <link href="https://zdddrszj.github.io/h-blog/2017/08/18/page-optimization/"/>
    <id>https://zdddrszj.github.io/h-blog/2017/08/18/page-optimization/</id>
    <published>2017-08-18T05:40:55.000Z</published>
    <updated>2018-10-07T00:51:27.779Z</updated>
    
    <content type="html"><![CDATA[<p>营销代有手段出，各领风骚数百天。要说现在哪些营销方式最能传播，屡屡刷爆朋友圈的 <code>H5</code> 页面肯定就是首当其冲的。所谓 <code>H5</code> 页面，即代表的是 <code>Html5</code> 页面，如今大部分浏览器已经支持<code>Html5</code> 页面。<code>Html5</code> 有强化 <code>Web</code> 网页的表现性能和追加本地数据库这些 <code>Web</code> 应用功能的优势。</p><p>广义论及的 <code>Html5</code> 实际指的是包含<code>HTML</code> 、<code>CSS</code> 和 <code>JavaScript</code> 在内的一套技术组合。今天主要阐述 <code>H5</code> 页面众多优化中的几个注意点。</p><h3><span id="页面按需渲染列表为例">页面按需渲染（列表为例）</span></h3><p>在原生 <code>APP</code> 开发中，如果一个页面很长，<code>UITableView</code> 和 <code>UICollectionView</code> 都有一个控件池，利用 <code>Cell复用机制</code> 来做优化，可以理解为根据当前用户所在屏幕位置进行渲染，其他不渲染或者少渲染，以提高页面性能。但是在 <code>Hybrid App（混合模式移动应用）</code> 模式中，对<code>WebView</code> 中 <code>H5</code> 页面来说，如果一个列表项加载有超过 200 条以上，而且每个项目都有半屏图片时，对于性能劣一点的手机来说，当用户滚动加载更多或者点击项目进入相应详细内容时，可以明显感觉页面迟钝，这 200 条项目渲染起来确实有点压力山大，所以这个优化需要 <code>H5</code> 自身来做。</p><p>在<code>WebView</code> 中<code>Scroll</code> 事件不同于在普通浏览器中，会在滚动事件结束时才会被触发，这里我们结合 <code>setTimeout</code> 来按需渲染，只需要设置 <code>visibility: hidden</code> 样式即可。</p><p>变量说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentTabIndex = <span class="number">0</span>, <span class="comment">// 当前列表索引（用于一个页面多个列表时）</span></span><br><span class="line">    preTabIndex = <span class="number">0</span>, <span class="comment">// 当前可视列表项索引</span></span><br><span class="line">    listArrayObject = &#123; <span class="comment">// 当前列表对象集合</span></span><br><span class="line">        <span class="string">'0'</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="string">'1'</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="string">'2'</span>: <span class="literal">null</span>,</span><br><span class="line">         ...</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>接口赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前列表索引 </span></span><br><span class="line"><span class="keyword">var</span> index = $(<span class="keyword">this</span>).index(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 把当前列表索引赋值给 currentTabIndex </span></span><br><span class="line">currentTabIndex = index; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前列表项</span></span><br><span class="line"><span class="keyword">var</span> lis = $(<span class="string">'.index_list'</span>).eq(index).find(<span class="string">'li'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 每页10条，加载的最后页</span></span><br><span class="line"><span class="keyword">var</span> collection = lis.slice(lis.length - <span class="number">10</span>, lis.length); </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对当前列表集合赋值</span></span><br><span class="line"><span class="keyword">if</span> (listArrayObject[index]) &#123;</span><br><span class="line">   listArrayObject[index].concat(collection)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    listArrayObject[index] = collection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按需渲染：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里利用 requestAnimationFrame() 函数，可以更合理的重新排列动作序列，</span></span><br><span class="line"><span class="comment">// 如果浏览器不支持，只好用 setTimeout() 代替</span></span><br><span class="line"><span class="keyword">var</span> rAF = <span class="built_in">window</span>.requestAnimationFrame  ||</span><br><span class="line">    <span class="built_in">window</span>.webkitRequestAnimationFrame  ||</span><br><span class="line">    <span class="built_in">window</span>.mozRequestAnimationFrame     ||</span><br><span class="line">    <span class="built_in">window</span>.oRequestAnimationFrame       ||</span><br><span class="line">    <span class="built_in">window</span>.msRequestAnimationFrame      ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123; <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示当前视窗中的列表项，隐藏超出部分</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showItem</span> (<span class="params">collection, index</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏之前显示的列表项</span></span><br><span class="line">    collection.slice(preTabIndex,preTabIndex + <span class="number">10</span>).find(<span class="string">'img'</span>).css(<span class="string">'visibility'</span>, <span class="string">'hidden'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展示当前列表项 默认显示 10 条</span></span><br><span class="line">    collection.slice(<span class="built_in">Math</span>.max(index - <span class="number">5</span>, <span class="number">0</span>), <span class="built_in">Math</span>.min(index + <span class="number">5</span>, collection.length)).find(<span class="string">'img'</span>).css(<span class="string">'visibility'</span>, <span class="string">'visible'</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 把当前列表项索引值存储在变量 preTabIndex 中，这样超出屏幕隐藏时就可以根据索引找到上一次显示的项目</span></span><br><span class="line">   <span class="comment">// 而不用遍历所有项目，时间复杂度从 O(n) 降到 O(10)</span></span><br><span class="line">    preTabIndex = <span class="built_in">Math</span>.max(index - <span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听滚动事件</span></span><br><span class="line"><span class="keyword">var</span> isScrollEnd = <span class="string">''</span>;</span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    isScrollEnd = <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听当前视口列表项</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isScrollFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isScrollEnd)&#123;</span><br><span class="line">        <span class="keyword">var</span> winScroTop = $(<span class="built_in">window</span>).scrollTop(),winHei = $(<span class="built_in">window</span>).height();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接从 listArrayObject 集合中获取列表项目，而不是遍历 DOM 树，提高速度</span></span><br><span class="line">        <span class="keyword">var</span> indexListLi = listArrayObject[currentTabIndex];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历列表项，步长为3，可根据屏幕最多承载项目数适当调整</span></span><br><span class="line">        <span class="keyword">if</span>(indexListLi &amp;&amp; indexListLi.length &gt; <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; indexListLi.length; i += <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">var</span> li = indexListLi.eq(i),</span><br><span class="line">                    top = li.offset().top;</span><br><span class="line">                <span class="keyword">if</span>(top &gt; winScroTop &amp;&amp; top &lt; winScroTop+winHei)&#123;</span><br><span class="line">                    <span class="comment">// 把当前列表集合和屏幕视口当前列表项索引传入函数 showItem() </span></span><br><span class="line">                    showItem(indexListLi, i);</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isScrollEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rAF(isScrollFun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用主函数</span></span><br><span class="line">isScrollFun();</span><br></pre></td></tr></table></figure><h3><span id="touch-事件">Touch 事件</span></h3><p>在 <code>Hybrid App</code> 开发中，若下拉刷新是原生的，那么当用户下拉刷新时：<br>对于 <code>Android</code> ：会触发 <code>touchstart</code> 、<code>touchcancle</code><br>对于 <code>IOS</code> ：会触发 <code>touchstart</code> 、<code>touchmove</code> 、<code>touchend</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;营销代有手段出，各领风骚数百天。要说现在哪些营销方式最能传播，屡屡刷爆朋友圈的 &lt;code&gt;H5&lt;/code&gt; 页面肯定就是首当其冲的。所谓 &lt;code&gt;H5&lt;/code&gt; 页面，即代表的是 &lt;code&gt;Html5&lt;/code&gt; 页面，如今大部分浏览器已经支持&lt;code&gt;H
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="html5" scheme="https://zdddrszj.github.io/h-blog/tags/html5/"/>
    
      <category term="performance" scheme="https://zdddrszj.github.io/h-blog/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>3D 旋转心</title>
    <link href="https://zdddrszj.github.io/h-blog/2017/07/06/rotating-ball/"/>
    <id>https://zdddrszj.github.io/h-blog/2017/07/06/rotating-ball/</id>
    <published>2017-07-06T03:05:12.000Z</published>
    <updated>2018-06-23T08:19:44.894Z</updated>
    
    <content type="html"><![CDATA[<p>亲爱的小伙伴，今天在这里 <code>用 css3 实现 3D 旋转心</code> 作为小礼物送给大家。</p><p>制作之前首先要学习一下 <code>border-radius</code> 基础知识，因为今天的这个心就是她的杰作。大家可以参考 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius" target="_blank" rel="noopener">CSS | MDN</a> 技术文档。</p><h3><span id="实现方法">实现方法</span></h3><p>大家看看下面这张图：</p><p><img src="https://cloud.githubusercontent.com/assets/9649921/11970598/cc5bf296-a968-11e5-88c6-969b01eacbdf.png" alt="qq 20151223112051"></p><p>青色直线上部分的红色弧线是不是像一个一半的 <code>❤</code> 呢？没错，只要将外面黄色矩形设置一定的圆角比例，就会变成红色矩形，其中圆角比例我已在图片上标注，同时将矩形左边和下边边框长度设为<code>0px</code>，在将矩形沿<code>Z 轴</code> 旋转 <code>45deg</code> ，我们就会看到下面这个图形：</p><p><img src="https://cloud.githubusercontent.com/assets/9649921/11970674/3fd95cda-a96a-11e5-87f5-872123ebf998.png" alt="1"></p><p>如果有36个这样的半心形，每个心形沿 <code>Y轴</code> 旋转 <code>10deg</code>，是不是就会变成下面这个图形呢？</p><p><img src="https://cloud.githubusercontent.com/assets/9649921/11970716/e43be77a-a96a-11e5-976f-32b2c4c3fea6.png" alt="2"></p><p>说到这里，估计大家已经知道大概代码了吧~~~</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>旋转心<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">            body&#123;background-color:black;&#125;</span></span><br><span class="line"><span class="undefined">            .heart_div&#123;</span></span><br><span class="line"><span class="undefined">                width:200px;</span></span><br><span class="line"><span class="undefined">                height:320px;</span></span><br><span class="line"><span class="undefined">                transform-style:preserve-3d;</span></span><br><span class="line"><span class="undefined">                position: relative;</span></span><br><span class="line"><span class="undefined">                left: 0;top:0;bottom: 0;right: 0;</span></span><br><span class="line"><span class="undefined">                margin:200px auto;</span></span><br><span class="line"><span class="undefined">                /*border:1px solid yellow;*/</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            .heart_div [class^=heart]&#123;</span></span><br><span class="line"><span class="undefined">                width:200px;</span></span><br><span class="line"><span class="undefined">                height:320px;</span></span><br><span class="line"><span class="undefined">                border:solid red;</span></span><br><span class="line"><span class="undefined">                border-width:2px 2px 0 0;</span></span><br><span class="line"><span class="undefined">                border-radius:50% 50% 0%/40% 50% 0%;</span></span><br><span class="line"><span class="undefined">                position: absolute;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"heart_div"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> heart_div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"heart_div"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&lt;<span class="number">37</span>;i++)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">/*给heart_div添加36个子元素 且类名为 heart1 heart2 ...*/</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span></span><br><span class="line"><span class="javascript">                div.className = <span class="string">"heart"</span>+i;</span></span><br><span class="line"><span class="javascript">                div.style.transform=<span class="string">"rotateY("</span>+i*<span class="number">10</span>+<span class="string">"deg)  rotateZ(45deg) translateX(60px)"</span>;</span></span><br><span class="line"><span class="undefined">                heart_div.appendChild(div);</span></span><br><span class="line"><span class="undefined">            &#125;           </span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要部分完成了，下面就加个旋转动画吧! 详细如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-class">.heart_div</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>:<span class="number">320px</span>;</span><br><span class="line">        <span class="attribute">transform-style</span>:preserve-<span class="number">3</span>d;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;<span class="attribute">top</span>:<span class="number">0</span>;<span class="attribute">bottom</span>: <span class="number">0</span>;<span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">margin</span>:<span class="number">200px</span> auto;</span><br><span class="line">        <span class="attribute">animation</span>:play <span class="number">10s</span> linear infinite;</span><br><span class="line">        <span class="attribute">-webkit-animation</span>:play <span class="number">10s</span> linear infinite;</span><br><span class="line">        <span class="attribute">-moz-animation</span>:play <span class="number">10s</span> linear infinite;</span><br><span class="line">        <span class="attribute">-o-animation</span>:play <span class="number">10s</span> linear infinite;</span><br><span class="line">        <span class="attribute">-ms-animation</span>:play <span class="number">10s</span> linear infinite;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">keyframes</span> play&#123;</span><br><span class="line">        <span class="selector-tag">to</span>&#123;</span><br><span class="line">            <span class="attribute">transform</span>:<span class="built_in">rotateY</span>(360deg) <span class="built_in">rotateX</span>(360deg) <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> play&#123;</span><br><span class="line">        <span class="selector-tag">to</span>&#123;</span><br><span class="line">            <span class="attribute">transform</span>:<span class="built_in">rotateY</span>(360deg) <span class="built_in">rotateX</span>(360deg) <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> play&#123;</span><br><span class="line">        <span class="selector-tag">to</span>&#123;</span><br><span class="line">            <span class="attribute">transform</span>:<span class="built_in">rotateY</span>(360deg) <span class="built_in">rotateX</span>(360deg) <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @-<span class="keyword">o</span>-<span class="keyword">keyframes</span> play&#123;</span><br><span class="line">        <span class="selector-tag">to</span>&#123;</span><br><span class="line">            <span class="attribute">transform</span>:<span class="built_in">rotateY</span>(360deg) <span class="built_in">rotateX</span>(360deg) <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @-<span class="keyword">ms</span>-<span class="keyword">keyframes</span> play&#123;</span><br><span class="line">        <span class="selector-tag">to</span>&#123;</span><br><span class="line">            <span class="attribute">transform</span>:<span class="built_in">rotateY</span>(360deg) <span class="built_in">rotateX</span>(360deg) <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><img class="emoji" alt=":bowtie:" src="https://assets-cdn.github.com/images/icons/emoji/bowtie.png" height="20" width="20"><img class="emoji" alt=":bowtie:" src="https://assets-cdn.github.com/images/icons/emoji/bowtie.png" height="20" width="20"><img class="emoji" alt=":bowtie:" src="https://assets-cdn.github.com/images/icons/emoji/bowtie.png" height="20" width="20">  好了，到这里就完工啦！！！</p><p><a href="http://yixunfe.github.io/blog/demo/43/demo.html" target="_blank" rel="noopener">查看demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;亲爱的小伙伴，今天在这里 &lt;code&gt;用 css3 实现 3D 旋转心&lt;/code&gt; 作为小礼物送给大家。&lt;/p&gt;
&lt;p&gt;制作之前首先要学习一下 &lt;code&gt;border-radius&lt;/code&gt; 基础知识，因为今天的这个心就是她的杰作。大家可以参考 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="https://zdddrszj.github.io/h-blog/tags/CSS3/"/>
    
      <category term="animation" scheme="https://zdddrszj.github.io/h-blog/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>3D 旋转立方体</title>
    <link href="https://zdddrszj.github.io/h-blog/2017/06/18/rotating-cube/"/>
    <id>https://zdddrszj.github.io/h-blog/2017/06/18/rotating-cube/</id>
    <published>2017-06-18T04:47:41.000Z</published>
    <updated>2018-06-23T08:19:44.895Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们一起来学习一下如何用 css3 变换实现小时候玩的小魔方立方体。但是要提前复习一下 3D 变换的相关知识，你可以看一下 <a href="http://www.w3cplus.com/content/css3-transform" target="_blank" rel="noopener">w3cplus博客</a> 或者    <a href="http://www.w3school.com.cn/cssref/pr_transform.asp" target="_blank" rel="noopener">w3school文档</a>，由于目前 webkit 内核对 css3   属性兼容性比较好，为代码简洁，这里我们只考虑 chrome 浏览器，其他浏览器读者可自行加相应前缀来实现。</p><p>好了，准备就绪之后那我们就开始进入正题吧。首先，我们来看一道数学题：请想一下6个正方形如何摆放能拼成一个正方体呢？当然，方式有很多，这里只提出一种，如下：</p><p><img src="https://cloud.githubusercontent.com/assets/9649921/11388537/62bc684a-9372-11e5-8dc2-1a17cab5d109.png" alt="w"></p><p>正方体 <code>前后</code> <code>左右</code> <code>上下</code> 分别用 <code>front</code> <code>back</code> <code>left</code> <code>right</code> <code>top</code> <code>bottom</code> 来表示。</p><h3><span id="实现方法">实现方法</span></h3><p>我们用自定义标签来实现，html 代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">cube</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">front</span>&gt;</span><span class="tag">&lt;/<span class="name">front</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">back</span>&gt;</span><span class="tag">&lt;/<span class="name">back</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">left</span>&gt;</span><span class="tag">&lt;/<span class="name">left</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">right</span>&gt;</span><span class="tag">&lt;/<span class="name">right</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">top</span>&gt;</span><span class="tag">&lt;/<span class="name">top</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">bottom</span>&gt;</span><span class="tag">&lt;/<span class="name">bottom</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">cube</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里，给背景一个紫色到黑色的径向渐变，样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">radial-gradient</span>(ellipse at center,#430d6d 0%,#000 100%);</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置正方体在浏览器窗口正中间，若想看到变换后的 3D 效果，需要给 <code>cube</code> 声明 3D 变换 <code>transform-style:preserve-3d;</code> ，同时给 <code>body</code> 设置 <code>视差</code> ，样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="comment">/*设置视差*/</span></span><br><span class="line">    <span class="attribute">perspective</span>:<span class="number">1000px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">cube</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">20em</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">20em</span>;</span><br><span class="line">    <span class="comment">/*在窗口居中*/</span></span><br><span class="line">    <span class="attribute">position</span>:absolute;<span class="attribute">left</span>:<span class="number">0</span>;<span class="attribute">top</span>:<span class="number">0</span>;<span class="attribute">right</span>:<span class="number">0</span>;<span class="attribute">bottom</span>:<span class="number">0</span>;<span class="attribute">margin</span>:auto;</span><br><span class="line">    <span class="comment">/*声明 3D 变换*/</span></span><br><span class="line">    <span class="attribute">transform-style</span>:preserve-<span class="number">3</span>d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>cube</code> 是正方体的父标签，6个子元素构成正方体，我们以父元素为相对坐标，分别对6个正方形相对父元素设置绝对定位。</p><p>这时，6个正方形和父元素重合，接下来，分别对其定位到上边图片对应位置，即 <code>back</code> <code>left</code> <code>right</code> <code>top</code> <code>bottom</code> 分别相对 <code>front</code> 进行位移和旋转，这样就可以拼成正方体啦~~~ 样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">front</span>&#123;</span><br><span class="line">     <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">     <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">     <span class="attribute">transform</span>:<span class="built_in">translateZ</span>(10em);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">back</span>&#123;</span><br><span class="line">     <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">     <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">     <span class="attribute">transform</span>:<span class="built_in">translateZ</span>(-10em);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">left</span>&#123;</span><br><span class="line">     <span class="attribute">left</span>:-<span class="number">20em</span>;</span><br><span class="line">     <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">     <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(10em) <span class="built_in">rotateY</span>(-90deg);</span><br><span class="line">     <span class="attribute">transform-origin</span>:right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">right</span>&#123;</span><br><span class="line">     <span class="attribute">right</span>:-<span class="number">20em</span>;</span><br><span class="line">     <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">     <span class="attribute">transform</span>:<span class="built_in">translateZ</span>(10em) <span class="built_in">rotateY</span>(90deg);</span><br><span class="line">     <span class="attribute">transform-origin</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">top</span>&#123;</span><br><span class="line">     <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">     <span class="attribute">top</span>:-<span class="number">20em</span>;</span><br><span class="line">     <span class="attribute">transform</span>:<span class="built_in">translateZ</span>(10em) <span class="built_in">rotateX</span>(90deg);</span><br><span class="line">     <span class="attribute">transform-origin</span>:bottom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">bottom</span>&#123;             </span><br><span class="line">     <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">     <span class="attribute">bottom</span>:-<span class="number">20em</span>;</span><br><span class="line">     <span class="attribute">transform</span>:<span class="built_in">translateZ</span>(10em) <span class="built_in">rotateX</span>(-90deg);</span><br><span class="line">     <span class="attribute">transform-origin</span>:top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：看到这里，大家可能不明白为什么上面的 <code>transform</code> 都要加一个 <code>transform:translateZ(10em)</code> ，这时因为接下来我们要给 <code>cube</code> 加旋转动画，<code>cube</code> 就会以自身中心为旋转点（对应正方体 <code>front</code> 这个面为旋转点），导致 <code>正方体</code> 不能以自身中心为旋转点进行旋转，故而我们把构成它的这6个面分别沿 <code>Z轴</code> 向正方向位移 <code>10em</code> ，就是正方形边长一半，这样 <code>cube</code> 中心点和 <code>正方体</code> 中心点 <code>重合</code>。</p><p>到这里我们已经完成一半了，可是我们这个正方体并不是小时候玩的魔方那样，每个面还有 <code>4x4=16</code> 个小正方形，这里设置 <code>8x8=64</code> 个小正方形（<code>20em/2.5em=8</code>）。css3 可以为我们的背景添加渐变，若想复习一下渐变知识，也可以看一下  <a href="http://www.w3cplus.com/content/css3-gradient" target="_blank" rel="noopener">w3cplus博客</a>。样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cube</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">linear-gradient</span>(rgba(0,0,0,0) <span class="number">0px</span>,<span class="built_in">rgba</span>(54,226,248,.5) <span class="number">0px</span>,</span><br><span class="line">                                        <span class="built_in">rgba</span>(54,226,248,.5) <span class="number">3px</span>,<span class="built_in">rgba</span>(0,0,0,0) <span class="number">3px</span>),</span><br><span class="line">               <span class="built_in">linear-gradient</span>(90deg,rgba(0,0,0,0) <span class="number">0px</span>,<span class="built_in">rgba</span>(54,226,248,.5) <span class="number">0px</span>,</span><br><span class="line">                                        <span class="built_in">rgba</span>(54,226,248,.5) <span class="number">3px</span>,<span class="built_in">rgba</span>(0,0,0,0) <span class="number">3px</span>);</span><br><span class="line">    <span class="attribute">background-size</span>:<span class="number">2.5em</span> <span class="number">2.5em</span>,<span class="number">2.5em</span> <span class="number">2.5em</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> solid <span class="built_in">rgba</span>(54,226,248,.5);</span><br><span class="line">    <span class="attribute">box-shadow</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">5em</span> <span class="built_in">rgba</span>(0,128,0,.4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步，为了正方体看上去不是呆板的，可以对 <code>cube</code> 加上一个动画，样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cube</span>&#123;</span><br><span class="line">    <span class="attribute">animation</span>:cube <span class="number">6s</span> linear infinite;</span><br><span class="line">    <span class="attribute">-webkit-animation</span>:cube <span class="number">6s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> cube&#123;</span><br><span class="line">    <span class="selector-tag">from</span>&#123;<span class="attribute">transform</span>:<span class="built_in">translateZ</span>(-10em) <span class="built_in">rotateX</span>(0deg) <span class="built_in">rotateY</span>(0deg);&#125;</span><br><span class="line">    <span class="selector-tag">to</span>&#123;<span class="attribute">transform</span>:<span class="built_in">translateZ</span>(-10em) <span class="built_in">rotateX</span>(360deg) <span class="built_in">rotateY</span>(360deg);&#125;</span><br><span class="line">&#125;</span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> cube&#123;</span><br><span class="line">    <span class="selector-tag">from</span>&#123;<span class="attribute">transform</span>:<span class="built_in">translateZ</span>(-10em) <span class="built_in">rotateX</span>(0deg) <span class="built_in">rotateY</span>(0deg);&#125;</span><br><span class="line">    <span class="selector-tag">to</span>&#123;<span class="attribute">transform</span>:<span class="built_in">translateZ</span>(-10em) <span class="built_in">rotateX</span>(360deg) <span class="built_in">rotateY</span>(360deg);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道大家对上边动画 <code>transform:translateZ(-10em)</code> 是否理解，这是因为我们在努力为 <code>cube</code> 和 <code>正方体</code> 中心点重合时设置了 <code>transform:translateZ(10em)</code>  。</p><p>若想在正方体中添加文字，设置字体大小要注意一下，chrome 浏览器默认字体大小<code>16px</code> ，正方形宽度 <code>16px*20em=320px</code> ，故 <code>line-height:320px</code> ；同时给字体设置多重阴影 <code>text-shadow</code>，可以达到立体效果，详细如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>放飞梦想<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">text-shadow</span>:<span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">#ccc</span>,<span class="number">0</span> <span class="number">2px</span> <span class="number">0</span> <span class="number">#bbb</span>,<span class="number">0</span> <span class="number">3px</span> <span class="number">0</span> <span class="number">#c9c9c9</span>,<span class="number">0</span> <span class="number">4px</span> <span class="number">0</span> <span class="number">#bbb</span>,<span class="number">0</span> <span class="number">4px</span> <span class="number">0</span> <span class="number">#b9b9b9</span>,<span class="number">0</span> <span class="number">5px</span> <span class="number">0</span> <span class="number">#aaa</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><g-emoji alias="smile" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png" ios-version="6.0">😄</g-emoji><g-emoji alias="smile" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png" ios-version="6.0">😄</g-emoji><g-emoji alias="smile" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png" ios-version="6.0">😄</g-emoji>  好了，到这里就完工啦！！！</p><p><a href="http://yixunfe.github.io/blog/demo/36/demo.html" target="_blank" rel="noopener">查看demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们一起来学习一下如何用 css3 变换实现小时候玩的小魔方立方体。但是要提前复习一下 3D 变换的相关知识，你可以看一下 &lt;a href=&quot;http://www.w3cplus.com/content/css3-transform&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="https://zdddrszj.github.io/h-blog/tags/CSS3/"/>
    
      <category term="animation" scheme="https://zdddrszj.github.io/h-blog/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>DOM 中的范围</title>
    <link href="https://zdddrszj.github.io/h-blog/2017/05/24/range/"/>
    <id>https://zdddrszj.github.io/h-blog/2017/05/24/range/</id>
    <published>2017-05-24T04:18:10.000Z</published>
    <updated>2018-06-23T08:19:44.894Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#dom-中的范围">DOM 中的范围</a><ul><li><a href="#1-用-dom-范围实现简单选择">1、用 DOM 范围实现简单选择</a></li><li><a href="#2-用-dom-范围实现复杂选择">2、用 DOM 范围实现复杂选择</a></li><li><a href="#3-操作-dom-范围中的内容">3、操作 DOM 范围中的内容</a></li><li><a href="#4-插入-dom-范围中的内容">4、插入 DOM 范围中的内容</a></li><li><a href="#5-折叠-dom-范围">5、折叠 DOM 范围</a></li><li><a href="#6-比较-dom-范围">6、比较 DOM 范围</a></li><li><a href="#7-复制-dom-范围">7、复制 DOM 范围</a></li><li><a href="#8-清理-dom-范围">8、清理 DOM 范围</a></li></ul></li><li><a href="#ie8及更早版本中的范围">IE8及更早版本中的范围</a><ul><li><a href="#1-用-ie-范围实现简单的选择">1、用 IE 范围实现简单的选择</a></li><li><a href="#2-使用-ie-范围实现复杂的选择">2、使用 IE 范围实现复杂的选择</a></li><li><a href="#3-操作-ie-范围中的内容">3、操作 IE 范围中的内容</a></li><li><a href="#4-折叠-ie-范围">4、折叠 IE 范围</a></li><li><a href="#5-比较-ie-范围">5、比较 IE 范围</a></li><li><a href="#6-复制-ie-范围">6、复制 IE 范围</a></li></ul></li></ul><!-- tocstop --><p>为了让开发人员更方便控制页面，<code>DOM2</code> 级遍历和范围模块定义了 <strong>范围 （range）</strong> 接口。通过范围可以选择文档中的一个区域，而不必考虑节点的界限（选择在后台完成，对用户是不可见的）。 <code>Firefox</code>、<code>Opera</code>、<code>Safari</code> 和 <code>Chrome</code> 都支持 <code>DOM</code> 范围。IE 以专有方式实现了自己的范围特性。</p><h1><span id="dom-中的范围">DOM 中的范围</span></h1><p><code>DOM2</code> 级在 <code>Document</code> 类型中定义了 <code>createRange()</code> 方法。在兼容 <code>DOM</code> 的浏览器中，使用这个方法属于 <code>document</code> 对象。使用 <code>hasFeature()</code> 或者直接检测该方法，都可以确定浏览器是否支持范围。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> supportsRange = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"Range"</span>,<span class="string">"2.0"</span>);</span><br><span class="line"><span class="keyword">var</span> alsoSupportsRange = (<span class="keyword">typeof</span> <span class="built_in">document</span>.createRange == <span class="string">"function"</span>);</span><br></pre></td></tr></table></figure><p>如果浏览器支持范围，那么就可以使用 <code>createRange()</code> 来创建 <code>DOM</code> 范围，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.createRange();</span><br></pre></td></tr></table></figure><p>与节点类似，新创建的范围与创建它的文档关联在一起，不能用于其他文档。<br>每个范围由一个<code>Range</code> 类型的实例表示，这个实例拥有很多属性和方法。下列属性提供了当前范围在文档中的位置信息：</p><p>1、<code>startContainer</code>：包含范围起点的节点（即选区中第一个节点的父节点）。<br>2、<code>startOffset</code>：范围在 startContainer 中起点的偏移量。<br>3、<code>endContainer</code>：包含范围终点的节点（即选区中最后一个节点的父节点）。<br>4、<code>endOffset</code>：范围在 endContainer 中终点的偏移量。<br>5、<code>commonAncestorContainer</code>：startContainer 和 endContainer 共同的祖先节点。</p><p>下面简单介绍一下范围的使用方法：</p><h3><span id="1-用-dom-范围实现简单选择">1、用 DOM 范围实现简单选择</span></h3><p>要使用范围来选择文档中的一部分，最简单的方式是使用 <code>selectNode()</code> 或 <code>selectNodeContents()</code>，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> range1 = <span class="built_in">document</span>.createRange(),</span></span><br><span class="line"><span class="javascript">                range2 = <span class="built_in">document</span>.createRange(),</span></span><br><span class="line"><span class="javascript">                p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</span></span><br><span class="line"><span class="undefined">            range1.selectNode(p1);</span></span><br><span class="line"><span class="undefined">            range2.selectNodeContents(p1);      </span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>两个范围包含文档中不同部分，如图：<br><img src="https://cloud.githubusercontent.com/assets/9649921/11467545/c48f7f2a-9783-11e5-8f56-0b63c1ade9b1.png" alt="1"><br>在调用 <code>selectNode()</code> 时，<code>startContainer</code>、<code>endContainer</code> 都等于传入节点的父节点，也就是 <code>document.body</code>。而 <code>startOffset</code> 属性等于给定节点在其父节点的 <code>childNodes</code> 集合中的索引（在这个例子中是 <code>1</code> ，因为兼容 <code>DOM</code> 的浏览器将空格算作一个文本节点），<code>endOffset</code> 等于 <code>startOffset</code> 加 <code>1</code> （因为只选择了一个节点）。<br>在调用 <code>selectNodeContents()</code> 时，<code>startContainer</code>、<code>endContainer</code> 等于传入的节点，即这个例子中的 <code>&lt;p&gt;</code> 元素。而 <code>startOffset</code> 属性始终等于 <code>0</code> ，因为范围从给定节点的第一个子节点开始。最后，<code>endOffset</code> 等于子节点的数量（node.childNodes.length），在这个例子中是 <code>2</code> 。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(range1.startContainer); <span class="comment">//&lt;body&gt;...&lt;/body&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(range2.startContainer); <span class="comment">//&lt;p id="p1"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(range1.endContainer); <span class="comment">//&lt;body&gt;...&lt;/body&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(range2.endContainer); <span class="comment">//&lt;p id="p1"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(range1.startOffset); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(range2.startOffset); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(range1.endOffset); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(range2.endOffset); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>此外，为了更精细地控制哪些节点包含在范围内，还可以使用下列方法：</p><p>1、<code>setStartBefore(refNode)</code>：将范围的起点设置在 refNode 之前。<br>2、<code>setStartAfter(refNode)</code>：将范围的起点设置在refNode 之后。<br>3、<code>setEndBefore(refNode)</code>：将范围的终点设置在 refNode 之前。<br>4、<code>setEndAfter(refNode)</code>：将范围的终点设置在 refNode 之后。</p><h3><span id="2-用-dom-范围实现复杂选择">2、用 DOM 范围实现复杂选择</span></h3><p>要创建复杂的范围就得使用 <code>setStart()</code> 和 <code>setEnd()</code> 方法。这两个方法都接受两个参数：一个参照节点和一个偏移量值。对 <code>setStart()</code> 来说，参照节点会变成 <code>startContainer</code>，而偏移量值会变   <code>startOffset</code> 。对于 <code>setEnd()</code> 来说，参照节点会变成 <code>endContainer</code> ，而偏移量值会变成 <code>endOffset</code>。<br>可以使用这两个方法来模拟 <code>selectNode()</code> 和 <code>selectNodeContents()</code> 。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.createRange(),</span><br><span class="line">    range2 = <span class="built_in">document</span>.createRange(),</span><br><span class="line">    p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>),</span><br><span class="line">    p1Index = <span class="number">-1</span>,i,len;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>, len = p1.parentNode.childNodes.length; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1.parentNode.childNodes[i] == p1)&#123;</span><br><span class="line">        p1Index = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">range1.setStart(p1.parentNode,p1Index);</span><br><span class="line">range1.setEnd(p1.parentNode,p1Index+<span class="number">1</span>);</span><br><span class="line">range2.setStart(p1,<span class="number">0</span>);</span><br><span class="line">range2.setEnd(p1,p1.childNodes.length);</span><br></pre></td></tr></table></figure><p>假设你只想选择前面 <code>HTML</code> 示例代码中从 <code>hello</code> 的 <code>llo</code> 到 <code>world!</code> 的 <code>o</code> ，可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>),</span><br><span class="line">    helloNode = p1.firstChild.firstChild,</span><br><span class="line">    worldNode = p1.lastChild;</span><br><span class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.createRange();</span><br><span class="line">range.setStart(helloNode,<span class="number">2</span>);</span><br><span class="line">range.setEnd(worldNode,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>由于 <code>helloNode</code> 和 <code>worldNode</code> 都是文本节点，因此它们分别变成了新建范围的 <code>startContainer</code> 和 <code>endContainer</code> 。此时 <code>startOffset</code> 和 <code>endOffset</code> 分别用以确定两个节点所包含的文本中的位置，而不是用以确定子节点的位置。如图：<br><img src="https://cloud.githubusercontent.com/assets/9649921/11468680/5ef0bfd6-978c-11e5-9c91-31f038224c73.png" alt="2"></p><h3><span id="3-操作-dom-范围中的内容">3、操作 DOM 范围中的内容</span></h3><p>对前面的例子而言，范围经过计算知道选取中缺少一个开始的 <code>&lt;b&gt;</code> 标签，因此就会在后台动态添加一个该标签，同时还会在前面加入一个表示结束的 <code>&lt;b&gt;</code> 标签。于是修改后的 <code>DOM</code> 就变成如下所示：<br><code>&lt;p&gt;&lt;b&gt;He&lt;/b&gt;&lt;b&gt;llo&lt;/b&gt; world!&lt;/p&gt;</code>。</p><p>像这样创建了范围之后，就可以使用各种方法对范围的内容进行操作了。<br>第一个方法：<code>deleteContents()</code>，从文档中删除范围所包含的内容。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range.deleteContents();</span><br></pre></td></tr></table></figure><p>执行这句代码之后，页面会显示如下 <code>HTML</code> 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;</span>rld!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二个方法：<code>extractContents()</code> ，也会从文档中移除范围选区，但会返回文档片段。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = range.extractContents();</span><br><span class="line">p1.parentNode.appendChild(fragment);</span><br></pre></td></tr></table></figure><p>执行这句代码之后，页面会显示如下 <code>HTML</code> 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;</span>rld!<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> wo</span><br></pre></td></tr></table></figure><p>第三个方法：<code>cloneContents()</code> ，会创建范围对象的一个副本，然后插入到其他地方。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = range.cloneContents();</span><br><span class="line">p1.parentNode.appendChild(fragment);</span><br></pre></td></tr></table></figure><p>执行这句代码之后，页面会显示如下 <code>HTML</code> 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> wo</span><br></pre></td></tr></table></figure><h3><span id="4-插入-dom-范围中的内容">4、插入 DOM 范围中的内容</span></h3><p>利用范围，可以删除或复制内容，也可以使用 <code>insertNode()</code> 方法像范围选区的开始处插入一个节点。假设我们在前面例子中的 <code>HTML</code> 前面插入以下 <code>HTML</code> 代码：<code>&lt;span style=&quot;color:red;&quot;&gt;Inserted text&lt;/span&gt;</code>  ，那么可以使用以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">"span"</span>);</span><br><span class="line">span.style.color = <span class="string">"red"</span>;</span><br><span class="line">span.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Inserted text"</span>));</span><br><span class="line">range.insertNode(span);</span><br></pre></td></tr></table></figure><p>执行这句代码之后，页面会显示如下 <code>HTML</code> 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color: red;"</span>&gt;</span>Inserted text<span class="tag">&lt;/<span class="name">span</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：<code>&lt;span&gt;</code> 正好被插入到了 <code>hello</code> 中的 <code>llo</code> 前面，而该位置就是范围选区的开始位置。还要注意的是，这里并没有添加或删除 <code>&lt;b&gt;</code> 元素，使用这种技术可以插入一些帮助提示信息，例如在打开新窗口的链接旁插入一幅图像。</p><p>除了像范围内部插入内容之外，还可以围绕范围插入内容，此时就要使用 <code>surroundContents()</code> 方法。该方法接受一个参数，即环绕范围内容的节点。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">range.selectNode(helloNode);</span><br><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">"span"</span>);</span><br><span class="line">span.style.backgroundColor = <span class="string">"yellow"</span>;  </span><br><span class="line">range.surroundContents(span);</span><br></pre></td></tr></table></figure><p>执行这句代码之后，会给范围选区加上一个黄色背景。得到的 <code>HTML</code> 代码如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color: yellow;"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：为了插入 <code>&lt;span&gt;</code> ，范围必须包含整个 <code>DOM</code> 选区（不能仅仅包含选中的 <code>DOM</code> 节点）。</p><h3><span id="5-折叠-dom-范围">5、折叠 DOM 范围</span></h3><p>所谓 <strong>折叠范围</strong> ，就是指范围中未选择文档的任何部分。使用 <code>collapse()</code> 方法来折叠范围，该方法接受一个参数，一个布尔值，表示要折叠到范围的哪一端。参数 <code>true</code> 表示要折叠到范围的起点，参数 <code>false</code> 表示要折叠到范围的终点。要确定范围已经折叠完毕，可以检查 <code>collapsed</code> 属性，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range.collapse(<span class="literal">true</span>); <span class="comment">//折叠到起点</span></span><br><span class="line">alert(range.collapsed); <span class="comment">//输出 true</span></span><br></pre></td></tr></table></figure><p>检测某个范围是否处于折叠状态，可以帮助我们确定范围中的两个节点是否紧密相邻。例如，对于下面的 <code>HTML</code> 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p2"</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们假设不知其实际构成（比如动态生成的），那么可以像下面这样创建一个范围：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">'p1'</span>),</span><br><span class="line">    p2 = <span class="built_in">document</span>.getElementById(<span class="string">'p2'</span>),</span><br><span class="line">    range = <span class="built_in">document</span>.createRange();</span><br><span class="line">range.setStartAfter(p1);</span><br><span class="line">range.setEndBefore(p2);</span><br><span class="line">alert(range.collapsed); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>在这个例子中，创建的范围是折叠的，所以 <code>p1</code> 和 <code>p1</code> 是相邻的。</p><h3><span id="6-比较-dom-范围">6、比较 DOM 范围</span></h3><p>在有多个范围的情况下，可以使用 <code>compareBoundaryPoints()</code> 方法来确定这些范围是否有公共的边界。这个方法接受两个参数：表示比较方式的常量值和要比较的范围。表示比较方式的常量如下：</p><p>1、<code>Range.START_TO_START</code>：比较第一个范围和第二个范围的起点；<br>2、<code>Range.START_TO_END</code>：比较第一个范围的起点和第二个范围的终点；<br>3、<code>Range.END_TO_END</code>：比较第一个范围和第二个范围的终点；<br>4、<code>Range.END_TO_START</code>：比较第一个范围的终点和第二个范围的起点；</p><p><code>compareBoundaryPoints()</code>方法返回值如下：如果第一个范围中的点位于第二个范围中的点之前，返回 <code>-1</code> ；如果两个点相等，返回 <code>0</code> ；如果第一个范围中的点位于第二个范围中的点之后，返回 <code>1</code> 。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.createRange(),</span><br><span class="line">    range2 = <span class="built_in">document</span>.createRange(),</span><br><span class="line">    p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</span><br><span class="line">range1.selectNodeContents(p1);</span><br><span class="line">range2.selectNodeContents(p1);</span><br><span class="line">range2.setEndBefore(p1.lastChild);</span><br><span class="line">alert(range1.compareBoundaryPoints(Range.START_TO_START,range2)); <span class="comment">//0</span></span><br><span class="line">alert(range1.compareBoundaryPoints(Range.END_TO_END,range2)); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>这个例子中，两个范围的起点相同，第一个范围的终点位于第二个范围的终点后面，如图：<br><img src="https://cloud.githubusercontent.com/assets/9649921/11490882/d46e1548-9817-11e5-975c-deb496beefce.png" alt="1"></p><h3><span id="7-复制-dom-范围">7、复制 DOM 范围</span></h3><p>可以使用 <code>cloneRange()</code> 方法复制范围，这个方法会创建调用它的范围的一个副本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newRange = range.cloneRange();</span><br></pre></td></tr></table></figure><p>新创建的范围与原来的范围包含相同的属性，而修改它的端点不会影响原来的范围。</p><h3><span id="8-清理-dom-范围">8、清理 DOM 范围</span></h3><p>在使用完范围后，最好是调用 <code>detach()</code> 方法，以便从创建范围的文档中分离出该范围。调用 <code>detach()</code> 之后，就可以放心地解除对范围的引用，从而让垃圾回收机制回收其内存了。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range.detach(); <span class="comment">//从文档中分离</span></span><br><span class="line">range = <span class="literal">null</span>; <span class="comment">//解除引用</span></span><br></pre></td></tr></table></figure><p>在使用范围的最后在执行这两个步骤是我们推荐的方式，一旦分离范围，就不能在恢复使用了。</p><h1><span id="ie8及更早版本中的范围">IE8及更早版本中的范围</span></h1><p><code>IE9</code> 支持范围，但 <code>IE8</code> 及之前版本不支持范围。不过，<code>IE8</code> 及早起版本支持一种类似的概念，即 <strong>文本范围（text range）</strong> 。文本范围是 <code>IE</code> 专有特性，主要处理文本（不一定是 <code>DOM</code> 节点）。通过 <code>&lt;body&gt;</code>、<br><code>&lt;button&gt;</code>、<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>等几个元素，可以调用 <code>createTextRange()</code> 方法来创建文本范围。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.body.createTextRange();</span><br></pre></td></tr></table></figure><p>与 <code>DOM</code> 范围类似，使用 <code>IE</code> 文本范围的方式也有很多种。</p><h3><span id="1-用-ie-范围实现简单的选择">1、用 IE 范围实现简单的选择</span></h3><p>选择页面中某一区域最简单的方式，就是使用范围的 <code>findText()</code> 方法。这个方法会找到第一次出现的给定文本，并将范围移过来以环绕该文本。如果没找到文本，这个方法返回 <code>false</code> ；否则，返回 <code>true</code> 。同样，仍然以下面的 <code>HTML</code> 代码为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要选择 <code>Hello</code> ，可以使用以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.body.createTextRange();</span><br><span class="line"><span class="keyword">var</span> found = range.findText(<span class="string">"Hello"</span>);</span><br><span class="line">alert(found); <span class="comment">//true</span></span><br><span class="line">alert(range.text); <span class="comment">//"Hello"</span></span><br></pre></td></tr></table></figure><p><code>IE</code> 中与 <code>DOM</code> 中的 <code>selectNode()</code> 方法最接近的方法是 <code>moveToElementText()</code> ，这个方法接受一个 <code>DOM</code> 元素，并选择该元素的所有文本，包含 <code>HTML</code> 标签，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.body.createTextRange(),</span><br><span class="line">    p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</span><br><span class="line">range.moveToElementText(p1);</span><br></pre></td></tr></table></figure><p>在文本范围中包含 <code>HTML</code> 的情况下，可以使用 <code>htmlText</code> 属性取得范围的全部内容，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(range.htmlText);</span><br></pre></td></tr></table></figure><p><code>IE</code> 的范围没有任何属性可以随着范围选区的变化而动态更新。不过，其 <code>parentElement()</code> 方法倒是与<code>DOM</code> 的 <code>commonAncestorContainer</code> 属性类似。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ancestor = range.parentElement();</span><br></pre></td></tr></table></figure><p>这样就得到了范围选区的父节点。</p><h3><span id="2-使用-ie-范围实现复杂的选择">2、使用 IE 范围实现复杂的选择</span></h3><p>在 <code>IE</code> 中创建复杂范围的方法，就是以增量向四周移动范围。为此，<code>IE</code> 提供了 4 个方法：<br><code>move()</code>、<code>moveStart()</code>、<code>moveEnd()</code> 和 <code>expand()</code>。<br>这些方法都接受两个参数：移动单位和移动单位的数量。其中，移动单位是下列一种字符串值：</p><p>1、<code>character</code>：这个字符地移动；<br>2、<code>word</code>：逐个单词（一系列非空格字符）地移动；<br>3、<code>sentence</code>：逐个句子（一系列以句号、问号或叹号结尾的字符）地移动；<br>4、<code>textedit</code>：移动到当前范围选区的开始或结束位置。</p><p>通过 <code>moveStart()</code> 方法可以移动到范围的起点，通过 <code>moveEnd()</code> 方法可以移动到范围的终点，移动的幅度由单位数量指定，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range.moveStart(<span class="string">"word"</span>,<span class="number">2</span>); <span class="comment">//起点移动 2 个单词</span></span><br><span class="line">range.moveEnd(<span class="string">"character"</span>,<span class="number">1</span>); <span class="comment">//终点移动 1 个字符</span></span><br></pre></td></tr></table></figure><p>使用 <code>expand()</code> 方法可以将范围规范化。换句话说，可以将任何部分选择的文本全部选中。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range.expand(<span class="string">"word"</span>); <span class="comment">//可以将整个单词选中</span></span><br></pre></td></tr></table></figure><p>而 <code>move()</code> 方法则先会折叠当前范围，然后再将范围移动到指定的单位数量，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range.move(<span class="string">"character"</span>,<span class="number">5</span>); <span class="comment">//移动 5 个字符</span></span><br></pre></td></tr></table></figure><h3><span id="3-操作-ie-范围中的内容">3、操作 IE 范围中的内容</span></h3><p>在 <code>IE</code> 中操作范围中的内容可以使用 <code>text</code> 属性或 <code>pasteHTML()</code> 方法。如前所述，通过 <code>text</code> 属性可以取得范围中的内容文本；但是，也可以通过这个属性设置范围中的内容文本。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.body.createTextRange();</span><br><span class="line">range.findText(<span class="string">"Hello"</span>);</span><br><span class="line">range.text = <span class="string">"Hi"</span>;</span><br></pre></td></tr></table></figure><p>执行以上代码后的 <code>HTML</code> 代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">p1</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时，<code>HTML</code> 标签保持不变，若要像范围中插入 <code>HTML</code> 代码，就得使用 <code>pasteHTMl()</code> 方法，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.body.createTextRange();</span><br><span class="line">range.findText(<span class="string">"Hello"</span>);</span><br><span class="line">range.pasteHTML(<span class="string">"&lt;em&gt;Hi&lt;/em&gt;"</span>);</span><br></pre></td></tr></table></figure><p>执行以上代码后的 <code>HTML</code> 代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">p1</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：在范围中包含 <code>HTML</code> 代码时，不应该使用 <code>pasteHTML()</code> ，因为这样很容易导致不可预料的结果（很可能是格式不正确的 <code>HTML</code>）。</p><h3><span id="4-折叠-ie-范围">4、折叠 IE 范围</span></h3><p><code>IE</code> 为范围提供的 <code>collapse()</code> 方法与 <code>DOM</code> 方法用法一样，可惜，没有对应的 <code>collapsed</code> 属性让我们知道范围是否已经折叠完毕。为此，必须使用 <code>boundingWidth</code> 属性，该属性返回范围的宽度（以像素为单位）。如果等于 <code>0</code> 说明范围已经折叠。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range.collapse(<span class="literal">true</span>);</span><br><span class="line">alert(range.boundingWidth); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>此外，还有 <code>boundingHeight</code>、<code>boundingLeft</code> 和<code>boundingTop</code> 等属性，可以提供一些位置信息。</p><h3><span id="5-比较-ie-范围">5、比较 IE 范围</span></h3><p><code>IE</code> 中的 <code>compareEndPoints()</code> 方法与 <code>DOM</code> 范围的 <code>compareBoundaryPoints()</code> 方法类似。这个方法接受两个参数：比较的类型和要比较的范围。比较类型的取值范围是下列几个字符串值：<code>StartToStart</code>、<br><code>StartToEnd</code>、<code>EndToEnd</code>、<code>EndToStart</code>。 <code>compareEndPoints()</code> 方法返回值同 <code>compareBoundaryPoints()</code> 方法。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.body.createTextRange(),</span><br><span class="line">    range2 = <span class="built_in">document</span>.body.createTextRange();</span><br><span class="line">range1.findText(<span class="string">"Hello world!"</span>);</span><br><span class="line">range2.findText(<span class="string">"Hello"</span>);</span><br><span class="line">alert(range1.compareEndPoints(<span class="string">"StartToStart"</span>,range2)); <span class="comment">//0</span></span><br><span class="line">alert(range1.compareEndPoints(<span class="string">"EndToEnd"</span>,range2)); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p><code>IE</code> 中还有两个方法，也用于比较范围：<code>isEqual()</code> 方法用于确定两个范围是否相等，<code>inRange()</code> 方法用于确定一个范围是否包含另一个范围。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.body.createTextRange(),</span><br><span class="line">    range2 = <span class="built_in">document</span>.body.createTextRange();</span><br><span class="line">range1.findText(<span class="string">"Hello world!"</span>);</span><br><span class="line">range2.findText(<span class="string">"Hello"</span>);</span><br><span class="line">alert(<span class="string">"range1.isEqual(range2):"</span>+range1.isEqual(range2)); <span class="comment">//false</span></span><br><span class="line">alert(<span class="string">"range1.inRange(range2):"</span>+range1.inRange(range2)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3><span id="6-复制-ie-范围">6、复制 IE 范围</span></h3><p>在 <code>IE</code> 中使用 <code>duplicate()</code> 方法可以复制文本范围，结果会创建原范围的一个副本，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newRange = range.duplicate();</span><br></pre></td></tr></table></figure><p>新创建的范围会带有与原范围完全相同的属性。<br><br></p><p><g-emoji alias="yum" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60b.png" ios-version="6.0">😋</g-emoji><g-emoji alias="yum" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60b.png" ios-version="6.0">😋</g-emoji><g-emoji alias="yum" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60b.png" ios-version="6.0">😋</g-emoji> 好了，基本知识就是这些，在这里和大家说拜拜啦~</p><p><a href="http://yixunfe.github.io/blog/demo/37/demo.html" target="_blank" rel="noopener">查看demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#dom-中的范围&quot;&gt;DOM 中的范围&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-用-dom-范围实现简单选择&quot;&gt;1、用 DOM 范围实现简单选择&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-用-dom-范
      
    
    </summary>
    
      <category term="前端" scheme="https://zdddrszj.github.io/h-blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="range" scheme="https://zdddrszj.github.io/h-blog/tags/range/"/>
    
  </entry>
  
</feed>
